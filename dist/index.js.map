{"version":3,"sources":["../src/index.ts","../src/utils/logging-utils.ts","../src/context.ts","../src/utils/array-utils.ts","../src/config/prompts.ts","../src/config/models.ts","../src/utils/string-utils.ts","../src/conditions.ts","../src/companions/companion.ts","../src/companions/auto-companion.ts","../src/companions/deputy.ts","../src/companions/moderator-deputy.ts","../src/chat.ts","../src/companions/chat-companion.ts","../src/companions/instruction-deputy.ts","../src/companions/test-deputy.ts","../src/db/in-memory-database.ts","../src/drama.ts","../src/model.ts","../src/prompter.ts","../src/utils/time-utils.ts"],"sourcesContent":["export { Chat } from './chat';\nexport type { ChatMessage, ChatSpeakerSelection } from './chat';\nexport { AutoCompanion } from \"./companions/auto-companion\";\nexport type { CompanionReply } from \"./companions/auto-companion\";\nexport { ChatCompanion } from \"./companions/chat-companion\";\nexport { Companion, TriggerOperation } from \"./companions/companion\";\nexport type { CompanionConfig, CompanionKind, CompanionScope, CompanionState } from \"./companions/companion\";\nexport { Deputy } from \"./companions/deputy\";\nexport { InstructionDeputy } from \"./companions/instruction-deputy\";\nexport { TestDeputy } from \"./companions/test-deputy\";\nexport type { Category, Condition, ConditionalLine, Tag } from \"./conditions\";\nexport { defaultModelConfig } from \"./config/models\";\nexport type { ModelConfig } from \"./config/models\";\nexport { defaultPromptConfig, defaultPromptTemplates } from \"./config/prompts\";\nexport { Context } from \"./context\";\nexport type { ContextData, ContextDataTypes, ContextDecorator } from \"./context\";\nexport type { ChatRecord, HistoryRecord, KeyValueRecord, PromptRecord, StateTypes } from \"./db/database\";\nexport { Database } from './db/database';\nexport { InMemoryDatabase } from './db/in-memory-database';\nexport { Drama } from './drama';\nexport type { Job, JobStatus } from \"./job\";\nexport { Model, ModelError } from \"./model\";\nexport { getRandomElement, randomArrayElement } from \"./utils/array-utils\";\n\n","const LOG_LEVEL = (process.env.DE_LOG_LEVEL || process.env.NEXT_PUBLIC_DE_LOG_LEVEL || 'info').toLowerCase();\nif (!['info', 'error', 'warning', 'debug', 'off'].includes(LOG_LEVEL)) {\n    throw new Error(`Undefined log level: ${LOG_LEVEL}`);\n}\n\nconst shouldLog = (level: string) => {\n    return level === LOG_LEVEL || LOG_LEVEL === 'debug';\n}\n\nexport const logger = {\n    info: shouldLog('info') ? console.info : () => { },\n    error: !shouldLog('off') ? console.error : () => { },\n    debug: shouldLog('debug') ? console.debug : () => { },\n    warn: (shouldLog('info') || shouldLog('warning')) ? console.warn : () => { },\n}","import { AutoCompanion } from \"./companions/auto-companion\";\nimport { CompanionConfig } from \"./companions/companion\";\nimport { JobResponse } from \"./model\";\nimport { logger } from \"./utils/logging-utils\";\n\nexport type ContextDataTypes =\n\t// everywhere\n\t\"companionNames\" |\t\t// The other companions around\n\t\"error\" |\t\t\t// An error that occurred\n\t\"conversationID\" |\t// A conversation can have multiple turns. They all share an ID\n\n\t// downstream (chat/app > companion / prompt])\n\t\"chat\" |\t\t\t// The compressed chat history (only for the moderator & care bot)\n\t\"knowledge\" |\t\t// Unlocked knowledge\n\t\"text\" |\t\t\t// A line of text provided by the client\n\t\"paragraph\" |\t\t// A paragraph of text provided by the client\n\t\"epilogue\" |\t\t// Text that should always go to the end of the system prompt\n\t\"input\" |\t\t\t// An input provided by a user\n\t\"action\" |\t\t\t// An active action\n\n\t// midstream (companion > prompt)\n\t\"persona\" |\t\t\t// The parts of the person that should be exhibited in this prompt\n\t\"job\" |\t\t\t\t// The instruction to the LLM\n\t\"mood\" |\t\t\t// Change the mood of the companion\n\n\t// upstream (companion > chat/app)\n\t\"question\" |\t\t// A question by the deputy\n\t\"answer\" |\t\t\t// An answer returned by a deputy\n\t\"excerpt\" |\t\t\t// An item that should be added to the chat instead of the \"message\".\n\t\"quote\" |\t\t\t// An item that should be added to the chat instead of a chat message\n\t\"message\" |\t\t\t// The message to be added to the chat history. Also goes into the prompt.\n\n\t// tool usage\n\t\"tool\" \t\t\t\t// A tool to use\n;\n\nexport type ContextDecorator = { type: ContextDataTypes, replacement: string };\nexport type ContextData = { type: ContextDataTypes, data: string };\n\nexport const defaultDecorators: ContextDecorator[] = [\n\t{ type: \"persona\", replacement: \"{{DATA}}\" },\n\t{ type: \"text\", replacement: \"USER TEXT=\\\"{{DATA}}\\\".\" },\n\t// { type: \"input\", replacement: \"USER TEXT=\\\"{{DATA}}\\\".\" },\n\t{ type: \"paragraph\", replacement: \"USER PARAGRAPH=\\\"{{DATA}}\\\"\" },\n\t{ type: \"companionNames\", replacement: \"OTHER CHAT PARTICIPANTS:\\n{{DATA}}\" },\n\t// { type: \"job\", replacement: \"JOB=\\\"{{DATA}}\\\"\" },\n\t{ type: \"job\", replacement: \"{{DATA}}\" },\n\t{ type: \"chat\", replacement: \"\\n{{DATA}}\" },\n\t{ type: \"knowledge\", replacement: \"\\n{{DATA}}\" },\n\t{ type: \"epilogue\", replacement: \"{{DATA}}\" },\n]\n\nexport class Context {\n\n\t// everywhere\n\tcompanionNames?: string;\t// The other companions around\n\terror?: string;\t\t\t\t// An error that occurred\n\tconversationID?: string;\t// A conversation can have multiple turns. They all share an ID\n\tinteractionID?: string;\t\t// An interaction is one string of activity triggered by the user (e.g. an action and all responses)\n\tsequenceID?: string;\t\t// ID for a sequence of actions\n\n\t// downstream (user > companion)\n\tchat?: string;\t\t\t\t// The compressed chat history (only for the moderator & care bot)\n\tknowledge?: string;\t\t\t// Unlocked knowledge\n\ttext?: string;\t\t\t\t// A line of text provided by the client\n\tparagraph?: string;\t\t\t// A paragraph of text provided by the client\n\tepilogue?: string;\t\t\t// Text that should always go to the end of the system prompt\n\tinput?: string;\t\t\t\t// An input provided by a user\n\taction?: string;\t\t\t// An active action\n\n\t// midstream (companion > prompt)\n\tpersona?: string;\t\t\t// The parts of the person that should be exhibited in this prompt\n\tjob?: string;\t\t\t\t// The instruction to the LLM\n\tmood?: string;\t\t\t\t// Change the mood of the companion\n\n\t// upstream (companion > user)\n\tquestion?: string;\t\t\t// A question by the deputy\n\tanswer?: string;\t\t\t// An answer returned by a deputy\n\texcerpt?: string;\t\t\t// An item that should be added to the chat instead of the \"message\".\n\tquote?: string;\t\t\t\t// An item that should be added to the chat instead of a chat message\n\tmessage?: string;\t\t\t// The message to be added to the chat history. Also goes into the prompt.\n\n\t// tool usage\n\ttool?: string; \t\t\t\t// A tool to use\n\n\n\t// INPUT: these go into the next companion\n\trecipient?: AutoCompanion;\t\t// Will be the next speaker (and receive this context) if set.\n\tcompanions: AutoCompanion[];\t// Companions to be added as other chat participants in the prompt\n\tchatID: string;\t\t\t\t\t// The chat this context belongs to\n\tsituation: string;\t\t\t\t// An identifier of the situation\n\t// data: ContextData[];\n\n\t// TRACKING: these get set whenever there's relevant activity\n\tinput_tokens: number = 0;\n\toutput_tokens: number = 0;\n\truntime: number = 0;\n\tresponse_id?: string;\n\n\tconstructor(recipient: AutoCompanion | undefined, companions: AutoCompanion[], chatID: string, situation: string, data?: ContextData[]) {\n\t\tthis.recipient = recipient;\n\t\tthis.companions = companions;\n\t\tthis.chatID = chatID;\n\t\tthis.situation = situation;\n\n\t\tif (data) {\n\t\t\tthis.companionNames = data.find(d => d.type == \"companionNames\")?.data;\n\t\t\tthis.error = data.find(d => d.type == \"error\")?.data;\n\t\t\tthis.conversationID = data.find(d => d.type == \"conversationID\")?.data;\n\t\t\tthis.chat = data.find(d => d.type == \"chat\")?.data;\n\t\t\tthis.knowledge = data.find(d => d.type == \"knowledge\")?.data;\n\t\t\tthis.text = data.find(d => d.type == \"text\")?.data;\n\t\t\tthis.paragraph = data.find(d => d.type == \"paragraph\")?.data;\n\t\t\tthis.epilogue = data.find(d => d.type == \"epilogue\")?.data;\n\t\t\tthis.input = data.find(d => d.type == \"input\")?.data;\n\t\t\tthis.action = data.find(d => d.type == \"action\")?.data;\n\t\t\tthis.persona = data.find(d => d.type == \"persona\")?.data;\n\t\t\tthis.job = data.find(d => d.type == \"job\")?.data;\n\t\t\tthis.mood = data.find(d => d.type == \"mood\")?.data;\n\t\t\tthis.question = data.find(d => d.type == \"question\")?.data;\n\t\t\tthis.answer = data.find(d => d.type == \"answer\")?.data;\n\t\t\tthis.excerpt = data.find(d => d.type == \"excerpt\")?.data;\n\t\t\tthis.quote = data.find(d => d.type == \"quote\")?.data;\n\t\t\tthis.message = data.find(d => d.type == \"message\")?.data;\n\t\t\tthis.tool = data.find(d => d.type == \"tool\")?.data;\n\t\t}\n\t}\n\n\taddUsage = (response: JobResponse) => {\n\t\tthis.response_id = response.id;\n\t\tthis.input_tokens += response.input_tokens || 0;\n\t\tthis.output_tokens += response.output_tokens || 0;\n\t\t// this.runtime += response.runtime || 0;\n\t}\n\n\tfindActionConfiguration = (configuration: CompanionConfig) => configuration.actions?.find(a => a.id == this.action);\n\n\tfindDelegate = (configuration: CompanionConfig, companions: AutoCompanion[]) => {\n\t\tconst action = this.findActionConfiguration(configuration);\n\t\tconst answer = this.hasAnswer();\n\n\t\tlogger.debug(\"ACTION: \" + action?.id);\n\t\tlogger.debug(\"ANSWER: \" + answer);\n\n\t\t// reply with deputy if there's an action but there's no answer yet. This will delegate the action.\n\t\tif (action && !answer) {\n\t\t\tconst deputy = companions.find(c => c.id == action.deputy);\n\n\t\t\tlogger.debug(\"Action \" + action.id + \" => \" + deputy + \" found.\");\n\n\t\t\tif (deputy) {\n\t\t\t\t// the deputy sets the next speaker\n\t\t\t\treturn deputy;\n\t\t\t} else {\n\t\t\t\tlogger.debug(\"Deputy \" + action.deputy + \" not found.\");\n\n\t\t\t\tlogger.debug(companions)\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\thasAnswer = () => this.answer || this.question || this.quote;\n\n\t// whether there is a field with context info or the deputy needs to ask for more information\n\tquery = () => this.text || this.input || this.paragraph;\n\n\n\t// getData = (type: ContextDataTypes) => this.data.find(d => d.type == type)?.data;\n\t// setData = (type: ContextDataTypes, data: string | undefined) => {\n\t// \tif (!data) {\n\t// \t\t// remove entry if data is undefined\n\t// \t\tthis.removeData(type);\n\t// \t\treturn;\n\t// \t}\n\t// \tthis.data = [...this.data.filter(d => d.type != type), { type: type, data: data }];\n\t// }\n\t// removeData = (type: ContextDataTypes) => this.data = this.data.filter(d => d.type != type);\n\n}","\nexport const getRandomElement = (array: any[]) => {\n\treturn array[Math.floor((Math.random() * array.length))];\n}\n\nexport const randomArrayElement = <T>(array: T[]) => {\n\treturn array[Math.floor((Math.random() * array.length))];\n}\n","\n/** TYPES */\n\nexport type PromptStyles = \"mistral\" | \"chatml\";\n\nexport type PromptConfig = {\n\tmax_prompt_length: number,\t\t// in characters!\n\tjob_in_chat: boolean,\t\t\t// whether job goes into system prompt (false) or chat (true)\n\tsystem_role_allowed: boolean,\t// some templates do not support \"system\" role e.g., Mistral instruction format\n}\n\nexport type PromptTemplate = {\n\tbos_token: string,\n\teos_token: string,\n\tunk_token: string,\n\tchat_template: string,\n}\n\n/** DEFAULTS */\n\nexport const defaultPromptConfig: PromptConfig = {\n\tmax_prompt_length: 1024 * 3 * 4,\n\tjob_in_chat: false,\n\tsystem_role_allowed: true,\n}\n\nexport const defaultPromptTemplates = {\n\t\"mistral\": {\n\t\tbos_token: \"<s>\",\n\t\teos_token: \"</s>\",\n\t\tunk_token: \"<unk>\",\n\t\tchat_template: \"{{ bos_token }}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if message['role'] == 'user' %}{{ '[INST] ' + message['content'] + ' [/INST]' }}{% elif message['role'] == 'assistant' %}{{ message['content'] + eos_token + ' ' }}{% else %}{{ raise_exception('Only user and assistant roles are supported!') }}{% endif %}{% endfor %}\",\n\t},\n\t\"chatml\": {\n\t\tbos_token: \"<s>\",\n\t\teos_token: \"<|im_end|>\",\n\t\tunk_token: \"<unk>\",\n\t\tchat_template: \"{% for message in messages %}{{'<|im_start|>' + message['role'] + '\\n' + message['content'] + '<|im_end|>' + '\\n'}}{% endfor %}<|im_start|>{{ speaker }}\\n\",\n\t},\n\n}","/*\n\nContext sizes:\nteknium/OpenHermes-2-Mistral-7B\t\t\t\t8192\t=> 30k characters (<4 letter tokens)\nteknium/OpenHermes-2p5-Mistral-7B\t\t\t8192\t=> 30k characters (<4 letter tokens)\nNousResearch/Nous-Hermes-2-Mistral-7B-DPO\t32768\t=> 120k characters (<4 letter tokens)\nNousResearch/Nous-Hermes-2-Mixtral-8x7B-DPO\t32768\t=> 120k characters (<4 letter tokens)\n\n1 token is ~4 characters.\n*/\n\nimport { defaultPromptConfig, defaultPromptTemplates } from \"./prompts\";\n\nexport type ModelConfig = typeof defaultModelConfig;\n\nexport const defaultModelConfig = {\n\tmodel: 'teknium/OpenHermes-2p5-Mistral-7B',\n\tn: 1,\n\tpresence_penalty: 0,\n\tfrequency_penalty: 0,\n\trepetition_penalty: 1.2,\n\n\ttemperature: 0.93,\n\tmax_tokens: 200,\n\ttop_p: 0.93,\n\ttop_k: 4,\n\t// min_p: 0.05,\n\n\tstop: \"\",\n\tstop_token_ids: [\n\t\t0\n\t],\n\tignore_eos: false,\n\tskip_special_tokens: true,\n\tspaces_between_special_tokens: true,\n\tstream: false,\n\n\textra: {\n\t\ttemplate: defaultPromptTemplates.chatml,\n\t\tpromptConfig: defaultPromptConfig,\n\t}\n}\n\nexport const largeContextModelConfig = {\n\t...defaultModelConfig,\n\n\tmodel: 'mistralai/Mixtral-8x7B-Instruct-v0.1', //'NousResearch/Nous-Hermes-2-Mixtral-8x7B-DPO',\n\tmax_tokens: 512,\n\textra: {\n\t\ttemplate: defaultPromptTemplates.mistral,\n\t\tpromptConfig: {\n\t\t\tmax_prompt_length: 100000,\n\t\t\tjob_in_chat: false,\n\t\t\tsystem_role_allowed: false,\n\t\t},\n\t}\n}\n\n","import { randomArrayElement } from \"./array-utils\";\nimport { logger } from \"./logging-utils\";\n\nexport const START_SENTENCES = [\n\t\"A screaming comes across the sky.\",\n\t\"Happy families are all alike; every unhappy family is unhappy in its own way.\",\n\t\"It was a bright cold day in April, and the clocks were striking thirteen.\",\n\t\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair.\",\n\t\"The sun shone, having no alternative, on the nothing new.\",\n\t\"Ships at a distance have every man's wish on board.\",\n\t\"I had the story, bit by bit, from various people, and, as generally happens in such cases, each time it was a different story.\",\n\t\"It was the day my grandmother exploded.\",\n\t\"Having placed in my mouth sufficient bread for three minutes' chewing, I withdrew my powers of sensual perception and retired into the privacy of my mind, my eyes and face assuming a vacant and preoccupied expression.\",\n\t\"It was love at first sight.\",\n\t\"He was born with a gift of laughter and a sense that the world was mad.\",\n\t\"Time is not a line but a dimension, like the dimensions of space.\",\n];\n\nexport function getLastStopSign(text: String) {\n\treturn Math.max(\n\t\ttext.lastIndexOf('.'),\n\t\ttext.lastIndexOf('!'),\n\t\ttext.lastIndexOf('?'),\n\t\t// text.lastIndexOf('\\''), // don't use this one because it's used in the middle of a sentence (like in this one twice)\n\t\t// text.lastIndexOf('\"'),\n\t\t// text.lastIndexOf('”'),\n\t\t// text.lastIndexOf('＂'),\n\t\t// text.lastIndexOf('〞'),\n\t\t// text.lastIndexOf('‟'),\n\t\ttext.lastIndexOf('…'),\n\t\t// text.lastIndexOf(\"...\"),\n\t\ttext.lastIndexOf(':'),\n\t\ttext.lastIndexOf(';'),\n\t\ttext.lastIndexOf('\\n'),\n\t);\n}\n\nexport function wantsSpace(character: string) {\n\treturn \".!?…\\\"”〞‟:;,)]}–—·\".includes(character);\n}\n\nexport function isCutoffSign(character: string) {\n\treturn \".!?…\".includes(character);\n}\n\nexport function getLastCutoffSign(text: String) {\n\treturn Math.max(\n\t\ttext.lastIndexOf('.'),\n\t\ttext.lastIndexOf('!'),\n\t\ttext.lastIndexOf('?'),\n\t\ttext.lastIndexOf('…'),\n\t\ttext.lastIndexOf(\"...\"),\n\t);\n}\n\nexport function getNextCut(text: String) {\n\treturn Math.min(\n\t\ttext.includes('.') ? text.indexOf('.') : text.length - 1,\n\t\ttext.includes('!') ? text.indexOf('!') : text.length - 1,\n\t\ttext.includes('?') ? text.indexOf('?') : text.length - 1,\n\t\ttext.includes('…') ? text.indexOf('…') : text.length - 1,\n\t\ttext.includes(\"...\") ? text.indexOf(\"...\") : text.length - 1,\n\t\ttext.includes(':') ? text.indexOf(':') : text.length - 1,\n\t\ttext.includes(';') ? text.indexOf(';') : text.length - 1,\n\t\t// text.includes('\\n') ? text.indexOf('\\n') : text.length - 1,\n\t\ttext.length - 1\n\t);\n}\n\nexport const checkPrompt = (text: string) => {\n\treturn /^([\\u0000-\\u024F])+$/u.test(text);\n}\n\nexport const makeSafe = (text: string) => {\n\treturn text.replace(/[^\\u0000-\\u024F]+/g, \"\");\n}\n\nexport type promptType = { text: string; startPosition: number; endPosition: number }\n\nexport function getSelectionString(text: string, startPosition: number, endPosition: number): promptType {\n\tif (!text || text.length < 3) return { text: \"\", startPosition: startPosition, endPosition: endPosition };\n\n\tconst maxCharacters = 250;\n\tconst hasSelection = (Math.abs(startPosition - endPosition) > 3); // we regard selections of more than 3 characters as valid\n\n\tlet finalString = \"\";\n\tlogger.debug(\"text: \" + text);\n\t// logger.debug(\"startPosition: \" + startPosition);\n\t// logger.debug(\"endPosition: \" + endPosition);\n\n\t// fill up until it would go over 250 characters\n\tlet punctuationIndexLeft: number = startPosition;\n\tlet insurance = 200;\n\tdo {\n\t\tconst remainingLeft = text.substring(Math.max(0, startPosition - maxCharacters), punctuationIndexLeft);\n\t\tconst lastSentenceLength = remainingLeft.length - (getLastStopSign(remainingLeft) + 1);\n\t\tpunctuationIndexLeft -= lastSentenceLength;\n\t\tconst lastSentence = text.substring(Math.max(0, punctuationIndexLeft), startPosition - finalString.length);\n\t\tif (punctuationIndexLeft != Math.max(0, startPosition - maxCharacters)) {\n\t\t\tfinalString = lastSentence + finalString;\n\t\t\t// logger.debug(\"--\");\n\t\t\t// logger.debug(\"remainingLeft: \" + remainingLeft);\n\t\t\t// logger.debug(\"remainingLeft length: \" + (punctuationIndexLeft - Math.max(0, startPosition - maxCharacters)));\n\t\t\t// logger.debug(\"lastSentenceLength: \" + lastSentenceLength);\n\t\t\t// logger.debug(\"punctuationIndexLeft: \" + punctuationIndexLeft);\n\t\t\t// logger.debug(\"Appending: \" + lastSentence);\n\t\t\t// logger.debug(\"String: \" + finalString);\n\n\t\t\tpunctuationIndexLeft -= 1; // go one left\n\t\t\tinsurance--;\n\t\t}\n\n\t} while (punctuationIndexLeft > 0 && punctuationIndexLeft != Math.max(0, startPosition - maxCharacters) && finalString.length < 250 && insurance > 0);\n\n\tconst startIndex =\n\t\thasSelection ? startPosition :\n\t\t\tMath.abs(punctuationIndexLeft - startPosition) < 3 ? startPosition - maxCharacters : // full para if cut is too close\n\t\t\t\tpunctuationIndexLeft < 0 ? 0 : Math.min(punctuationIndexLeft + 1, startPosition); // -1 because we add 1 below\n\n\t// find end of sentence if in the middle\n\tconst remainingLength = maxCharacters - (endPosition - startIndex);\n\tconst rightString = text && text.substring(endPosition, endPosition + remainingLength);\n\tconst punctuationIndexRight = getNextCut(rightString) + 1 + endPosition;\n\t// const endIndex =\n\t//   hasSelection ? endPosition :\n\t//   Math.min(Math.max(punctuationIndexRight, endPosition), text.length); // take the one point further right\n\n\tfinalString = text.substring(startIndex, startPosition);\n\tfinalString = finalString.replaceAll(\"\\n\\n\", \" \");\n\tfinalString = finalString.replaceAll(\"  \", \" \");\n\tfinalString = finalString.trim();\n\n\tlogger.debug(\"Result string: \" + finalString);\n\n\tif (finalString.length == 0) finalString = \"\";\n\n\treturn { text: finalString, startPosition: startPosition - finalString.length, endPosition: startPosition };\n}\n\nexport function getSelectionStringOld(text: string, startPosition: number, endPosition: number): promptType {\n\tif (!text || text.length < 3) return { text: \"\", startPosition: startPosition, endPosition: endPosition };\n\n\tconst maxCharacters = 250;\n\tconst hasSelection = (Math.abs(startPosition - endPosition) > 3); // we regard selections of more than 3 characters as valid\n\n\tlet finalString = \"\";\n\t// logger.debug(\"text: \" + text);\n\t// logger.debug(\"startPosition: \" + startPosition);\n\t// logger.debug(\"endPosition: \" + endPosition);\n\n\t// fill up until it would go over 250 characters\n\tlet punctuationIndexLeft: number = startPosition;\n\tlet insurance = 200;\n\tdo {\n\t\tconst remainingLeft = text.substring(Math.max(0, startPosition - maxCharacters), punctuationIndexLeft);\n\t\tconst lastSentenceLength = remainingLeft.length - (getLastStopSign(remainingLeft) + 1);\n\t\tpunctuationIndexLeft -= lastSentenceLength;\n\t\tconst lastSentence = text.substring(Math.max(0, punctuationIndexLeft), startPosition - finalString.length);\n\t\tif (punctuationIndexLeft != Math.max(0, startPosition - maxCharacters)) {\n\t\t\tfinalString = lastSentence + finalString;\n\t\t\t// logger.debug(\"--\");\n\t\t\t// logger.debug(\"remainingLeft: \" + remainingLeft);\n\t\t\t// logger.debug(\"remainingLeft length: \" + (punctuationIndexLeft - Math.max(0, startPosition - maxCharacters)));\n\t\t\t// logger.debug(\"lastSentenceLength: \" + lastSentenceLength);\n\t\t\t// logger.debug(\"punctuationIndexLeft: \" + punctuationIndexLeft);\n\t\t\t// logger.debug(\"Appending: \" + lastSentence);\n\t\t\t// logger.debug(\"String: \" + finalString);\n\n\t\t\tpunctuationIndexLeft -= 1; // go one left\n\t\t\tinsurance--;\n\t\t}\n\n\t} while (punctuationIndexLeft > 0 && punctuationIndexLeft != Math.max(0, startPosition - maxCharacters) && finalString.length < 250 && insurance > 0);\n\n\tconst startIndex =\n\t\thasSelection ? startPosition :\n\t\t\tMath.abs(punctuationIndexLeft - startPosition) < 3 ? startPosition - maxCharacters : // full para if cut is too close\n\t\t\t\tpunctuationIndexLeft < 0 ? 0 : Math.min(punctuationIndexLeft + 1, startPosition); // -1 because we add 1 below\n\n\t// find end of sentence if in the middle\n\tconst remainingLength = maxCharacters - (endPosition - startIndex);\n\tconst rightString = text && text.substring(endPosition, endPosition + remainingLength);\n\tconst punctuationIndexRight = getNextCut(rightString) + 1 + endPosition;\n\tconst endIndex =\n\t\thasSelection ? endPosition :\n\t\t\tMath.min(Math.max(punctuationIndexRight, endPosition), text.length); // take the one point further right\n\n\t// logger.debug(\"Left string: \" + (text && ));\n\t// logger.debug(\"Right string: \" + (text && text.substring(startPosition, endIndex)));\n\t// logger.debug(\"Position \" + startPosition + \" -- \" + endPosition);\n\t// logger.debug(\"Punctuation: \" + punctuationIndexLeft + \" -- \" + punctuationIndexRight);\n\t// logger.debug(\"Indices \" + startIndex + \" -- \" + endIndex);\n\n\t// This works but there are still edge cases where the selection could be >=250 characters and start in hte middle of a word.\n\t// If it's too long we cut in the calling function anyway, so all good.\n\t// And others where the selection is empty.\n\n\tfinalString += text.substring(startPosition, endIndex);\n\tfinalString = finalString.replaceAll(\"\\n\\n\", \" \");\n\tfinalString = finalString.replaceAll(\"  \", \" \");\n\tfinalString = finalString.trim();\n\n\tlogger.debug(\"Result string: \" + finalString);\n\n\tif (finalString.length == 0) finalString = \"\";\n\n\treturn { text: finalString, startPosition: startIndex, endPosition: endIndex };\n}\n\n// returns index of the previous cut relative to the whole string\nexport function findPreviousCut(text: string, startPosition: number = 0): number {\n\t// const cutIndex = getNextCut(text.substring(startPosition, text.length));\n\n\tconst searchStartIndex = startPosition;\n\n\tconst cutIndex =\n\t\tMath.max(\n\t\t\ttext.lastIndexOf('.', searchStartIndex),\n\t\t\ttext.lastIndexOf('!', searchStartIndex),\n\t\t\ttext.lastIndexOf('?', searchStartIndex),\n\t\t\ttext.lastIndexOf('…', searchStartIndex),\n\t\t\t// text.lastIndexOf(\"...\"),\n\t\t\ttext.lastIndexOf(\":\", searchStartIndex),\n\t\t\ttext.lastIndexOf(\";\", searchStartIndex),\n\t\t);\n\n\treturn cutIndex;\n}\n\n\n// returns index of the next cut relative to the whole string\nexport function findCut(text: string, startPosition: number = 0): number {\n\treturn startPosition + getNextCut(text.substring(startPosition, text.length));\n}\n\nconst countDoubleQuotes = (text: string) => text.split('\"').length - 1;\n\nexport function removeLineBreaks(text: string): string {\n\tconst cleanedText = text\n\t\t.replace(/[\\r\\n]/g, \" \")            // replace \\r or \\n with space\n\t\t.replace(/[\\s]{2,}/g, \" \")          // replace 2 or more whitespaces (except newlines) with a single one, ref: https://stackoverflow.com/a/45046733\n\n\treturn cleanedText;\n}\n\n// the following is the cleaning function for uploaded text as well as snippets\nexport function cleanText(text: string): string {\n\n\tconst cleanedText = text\n\n\t\t// the following were active when we still supported quotations:\n\t\t// .replaceAll(/[«»““”„‟≪≫《》〝〞〟＂″‶]/g, \"\\\"\") // replacing all weird quotes a la: https://stackoverflow.com/a/47173868/17478452\n\t\t// .replaceAll(/[ʻʼʽ٬‘’‚‛՚︐]/g, \"'\")             // replacing all weird quotes a la: https://stackoverflow.com/a/47173868/17478452\n\t\t// .replaceAll(/\"+/g, \"\\\"\")                    // replace duplicate double quotation marks\n\t\t// .replaceAll(/'+/g, \"'\")                     // replace duplicate single quotation marks\n\t\t// .replaceAll(/([\\.\\?!])\"(\\S)/g, \"$1\\\" $2\")        // add a space after .\"\n\t\t// .replaceAll(/([\\.\\?!])'(\\S)/g, \"$1' $2\")         // add a space after .'\n\n\t\t.replace(/[ʻʼʽ٬‘‚‛՚︐«»““”„‟≪≫《》〝〞〟＂″‶\"]/g, \"\") // remove all kinds of quotation marks\n\t\t// .replaceAll(/[\\x00-\\x08\\x0E-\\x1F\\x7F-\\uFFFF]/g, '')   // ASCII only (strip unicode)\n\t\t.replace(/([\\.\\?!:;,])(\\S)/g, \"$1 $2\")   // replace missing whitespace after a sentence end with whitespace\n\t\t.replace(/[\\r\\n]{2,}/g, \"\\n\")            // replace 2 or more newlines with a single one\n\t\t.replace(/[^\\S\\r\\n]{2,}/g, \" \")          // replace 2 or more whitespaces (except newlines) with a single one, ref: https://stackoverflow.com/a/45046733\n\t\t;\n\n\t// logger.debug(cleanedText)\n\treturn cleanedText;\n}\n\nexport function cleanTextMinimal(text: string): string {\n\n\tconst cleanedText = text\n\n\t\t.replace(/[ʻʼʽ٬‘‚‛՚︐«»““”„‟≪≫《》〝〞〟＂″‶\"]/g, \"\") // remove all kinds of quotation marks\n\t\t.replace(/([\\.\\?!:;,])(\\S)/g, \"$1 $2\")   // replace missing whitespace after a sentence end with whitespace\n\t\t// .replaceAll(/[\\r\\n]{2,}/g, \"\\n\")            // replace 2 or more newlines with a single one\n\t\t// .replaceAll(/[^\\S\\r\\n]{2,}/g, \" \")          // replace 2 or more whitespaces (except newlines) with a single one, ref: https://stackoverflow.com/a/45046733\n\t\t;\n\n\t// logger.debug(cleanedText)\n\treturn cleanedText;\n}\n\n\nexport function cleanSnippet(text: string, minLength: number = 20, maintainNewlines: boolean = false): string {\n\tif (text == null) return \"\";\n\n\tlet cleanedText = maintainNewlines ? cleanTextMinimal(text) : cleanText(text);\n\tlet lastPunctuationIndex: number = getLastCutoffSign(cleanedText) + 1;\n\tif (lastPunctuationIndex < cleanedText.length && lastPunctuationIndex > minLength) {\n\t\tcleanedText = cleanedText.substring(0, lastPunctuationIndex);\n\t}\n\n\t// logger.debug(\"string: \" + cleanedText);\n\t// logger.debug(\"last character: \" + cleanedText[cleanedText.length - 1]);\n\n\tif (countDoubleQuotes(cleanedText) % 2 != 0 && isCutoffSign(cleanedText[cleanedText.length - 1])) return cleanedText + \"\\\"\"; // add a \" character if we have an uneven number of quotation marks\n\n\treturn cleanedText;\n}\n\nexport const titleCase = (str: string) => {\n\treturn str.toLowerCase().split(' ').map(function (word) {\n\t\treturn word.length > 1 ? word.replace(word[0], word[0].toUpperCase()) : word;\n\t}).join(' ');\n}\n\nexport const deGutenberg = (text: string) => {\n\tif (text.startsWith(\"The Project Gutenberg\")) {\n\t\t// const withoutPreamble = text.substring(0, text.indexOf())\n\t\tconst lines = text.split(/\\r\\n/);\n\t\tlet startIndex = 0;\n\t\tlet endIndex = text.length - 1;\n\t\tlet index = 0;\n\t\tlines.forEach((line, lineIndex) => {\n\t\t\tif (line.startsWith(\"***END OF\") || line.startsWith(\"*** END OF\")) endIndex = index + lineIndex * 2 - 1; // cut before current line but include newlines (via lineIndex)\n\t\t\tif (line.startsWith(\"***START OF\") || line.startsWith(\"*** START OF\")) startIndex = index + line.length + lineIndex * 2; // include current line and the newlines (via lineIndex)\n\t\t\tindex += line.length;\n\t\t})\n\t\tlogger.debug(\"Gutenbook of \" + index + \" characters (\" + lines.length + \" lines)! Keeping from \" + startIndex + \" to \" + endIndex);\n\t\treturn text.substring(startIndex, endIndex);\n\t}\n\treturn text;\n}\n\n/*\nA word has 4.7 characters on average\nA sentence has 10-15 words (= 47-70.5 characters)\nA paragraph has 200-300 words on average (= 940-1410 characters)\nA page has 2000 characters on average\n */\n\nconst shortenText = (text: string, length: number) => {\n\tconst startIndex = text.length - length;\n\tif (startIndex < 0) return text;\n\n\tconst shorterText = text.substring(startIndex);\n\tconst nextCutoff = getNextCut(shorterText) + 1;\n\n\tif (nextCutoff < shorterText.length) return shorterText.substring(nextCutoff);\n\n\treturn shorterText;\n}\n\nexport const getLastParagraph = (document: string) => {\n\tif (document.length <= 1000) return cleanText(document);\n\n\tconst paragraphs = cleanText(document).split(\"\\n\");\n\tconst selectedParagraph = paragraphs.pop();\n\n\treturn selectedParagraph ? shortenText(selectedParagraph, 1000) : shortenText(document, 1000);\n}\n\nexport const getLastSentence = (document: string) => {\n\tconst trimmedDocument = cleanText(document.trim());\n\n\tif (trimmedDocument.length <= 70) return trimmedDocument.trim();\n\n\tconst lastStopSign = getLastStopSign(trimmedDocument.substring(0, trimmedDocument.length - 3)) + 1;\n\tif (lastStopSign >= 0 && lastStopSign < trimmedDocument.length) return trimmedDocument.substring(lastStopSign).trim();\n\n\treturn trimmedDocument.substring(trimmedDocument.length - 70).trim();\n}\n\nexport const getRandomParagraph = (document: string) => {\n\tif (document.length <= 1000) return document;\n\n\tconst paragraphs = cleanText(document).split(\"\\n\");\n\tif (paragraphs.length < 2) return getLastParagraph(document);\n\tconst selectedParagraph = randomArrayElement(paragraphs);\n\treturn shortenText(selectedParagraph, 1000).trim();\n}\n\nexport const capitalizeFirstLetter = (string: string) => {\n\treturn string[0].toUpperCase() + string.slice(1);\n}\n","import { KeyValueRecord, StateTypes } from \"./db/database\";\nimport { logger } from \"./utils/logging-utils\";\n\nexport type Tag = \"none\" | \"event\" | \"action\";\nexport type Category = \"greeting\" | \"confirmation\" | \"sign-off\";\n\n/**\n * Some shortcuts for listing a number of standard utterances that are produced without using the LLM.\n * @date 31/01/2024\n *\n * @export\n * @typedef {ConditionalLine}\n */\nexport type ConditionalLine = {\n\tcategory?: Category,\n\tlines: string[],\n\tcondition?: Condition,\n}\n\n/**\n * A condition can either be a tag (if it is companion-dependent) or the name of a world data key. It is always\n * compared with a lower boundary (inclusive, >=) and an upper boundary (exclusive, <).\n * @date 31/01/2024\n *\n * @export\n * @typedef {Condition}\n */\nexport type Condition = {\n\ttag: Tag | string,\n\tmin?: number,\n\tmax?: number,\n\tvalue?: StateTypes,\n}\n\n/**\n * Evaluate a condition\n * @param {Condition} condition\n * @param {KeyValueRecord[]} worldState\n * @returns {boolean}\n */\nexport const evaluateCondition = (condition: Condition, worldState: KeyValueRecord[]) => {\n\n\tconst min = condition.min || 0;\n\tconst max = condition.max || Number.MAX_SAFE_INTEGER;\n\n\tswitch (condition.tag) {\n\t\tcase \"none\":\n\t\t\treturn true;\n\t\tcase \"event\":\n\t\t\tconst activeEvent = worldState.find(entry => entry.key == condition.value);\n\t\t\treturn activeEvent != undefined && activeEvent.value as boolean;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (typeof condition.tag == \"string\") {\n\t\tconst entry = worldState.find(entry => entry.key == condition.tag);\n\n\t\tif (!entry) {\n\t\t\tlogger.error(\"Invalid trigger: '\" + condition.tag + \"' not found in world state.\")\n\t\t\treturn false; // entry not found\n\t\t}\n\t\tif (condition.value && typeof condition.value != typeof entry.value) {\n\t\t\tlogger.error(\"Invalid trigger: \" + condition.tag + \" has a different type than the corresponding world state.\")\n\t\t\treturn false; // entry not found\n\t\t}\n\n\t\t// we check for an interval\n\t\tif (typeof entry.value == \"number\" && condition.value == undefined)\n\t\t\treturn entry.value >= min && entry.value < max;\n\n\t\t// we compare to a value\n\t\treturn (entry.value === condition.value);\n\t}\n\n\treturn false;\n}\n","import { Category, Condition, ConditionalLine, evaluateCondition } from \"../conditions\";\nimport { ModelConfig, defaultModelConfig } from \"../config/models\";\nimport { Drama } from \"../drama\";\nimport { randomArrayElement } from \"../utils/array-utils\";\nimport { AutoCompanion } from \"./auto-companion\";\n\nexport type CompanionState = \"disabled\" | \"free\" | \"active\" | \"autonomous\" | \"chat-only\";\nexport type CompanionKind = \"user\" | \"npc\" | \"shell\";\nexport type CompanionScope = \"document\" | \"last_sentence\" | \"last_paragraph\" | \"random_paragraph\" | \"screen\" | \"some\";\n\n// Scope overrides the deputy's default scope\nexport type ActionDescription = { id: string, label?: string, deputy: string, condition?: Condition, fallback?: CompanionScope }\n\nexport type TriggerOperation = \"set\" | \"add\" | \"send\";\nexport type TriggerDescription = { action: string | TriggerOperation, effect?: Condition, condition: Condition }\n\nexport type CompanionConfig = {\n\tname: string,\n\tclass: (new (configuration: CompanionConfig, drama: Drama) => AutoCompanion),\n\tdescription: string,\n\tbase_prompt: string,\n\tkind: CompanionKind,\n\n\tmoods?: {\n\t\tprobability: number,\n\t\tlabel: string,\n\t\tprompt: string,\n\t}[],\n\n\tbio?: string,\n\tavatar?: string,\n\tjob?: string,\n\tsituations?: { id: string, prompt: string }[],\n\tknowledge?: ConditionalLine[],\n\tmottos?: ConditionalLine[],\n\n\tactions?: ActionDescription[],\n\ttriggers?: TriggerDescription[],\n\n\tmodelConfig?: ModelConfig,\n\ttemperature?: number,\n\n\tscope?: CompanionScope;\n};\n\nexport abstract class Companion {\n\tid: string;\n\tconfiguration: CompanionConfig;\n\tstatus: CompanionState;\n\n\t// statistics\n\tinteractions: number;\n\tactions: number;\n\n\tmood: { label: string, prompt?: string } = { label: \"neutral\", prompt: undefined };\n\n\tpublic static toID = (name: string) => { return name.toLowerCase(); }\n\n\tconstructor(configuration: CompanionConfig) {\n\t\tthis.configuration = configuration;\n\t\tthis.id = Companion.toID(configuration.name);\n\t\tthis.interactions = 0;\n\t\tthis.actions = 0;\n\t\tthis.status = \"active\";\n\t\tthis.configuration.modelConfig = configuration.modelConfig || defaultModelConfig;\n\n\t\tif (configuration.temperature) {\n\t\t\tthis.configuration.modelConfig.temperature = configuration.temperature;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tgetBasePrompt = () => this.configuration.base_prompt;\n\n\tgetMottosByEvent = (event: Category, drama: Drama) => {\n\t\treturn this.configuration.mottos!\n\t\t\t.filter(m => m.category == event && m.condition && evaluateCondition(m.condition, drama.worldState))\n\t\t\t.flatMap(v => v.lines)\n\t\t\t|| [];\n\t}\n\n\tgetRandomMottoByEvent = (event: Category, drama: Drama): string => {\n\t\tconst userName = drama.getWorldStateValue(\"USERNAME\");\n\t\tif (userName)\n\t\t\treturn randomArrayElement<string>(this.getMottosByEvent(event, drama)).replace(\"{{USERNAME}}\", userName as string) || \"\";\n\t\telse\n\t\t\treturn randomArrayElement<string>(this.getMottosByEvent(event, drama)) || \"\";\n\t}\n\n\tvalueOf = () => this.id; // id is unique and if companion has the same it's the same companion\n\n\n}","import { Chat, ChatMessage } from \"../chat\";\nimport { ActionDescription, Companion, CompanionConfig } from \"./companion\";\nimport { Context, ContextDataTypes, ContextDecorator } from \"../context\";\nimport { Drama } from \"../drama\";\nimport { Job } from \"../job\";\nimport { Deputy } from \"./deputy\";\n\nexport type CompanionReply = [boolean, Context | undefined];\nexport type ReplyTriggerTypes = undefined | number | AutoCompanion | string | ((context: Context, sender?: AutoCompanion) => boolean);\nexport type ReplyFunctionAsync = (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion) => Promise<CompanionReply>;\n\nexport class AutoCompanion extends Companion {\n\n\tprotected drama: Drama;\n\tprotected decorators: ContextDecorator[] = [];\n\tprotected replyFunctions: { trigger: ReplyTriggerTypes | ReplyTriggerTypes[], replyFunction: ReplyFunctionAsync }[];\n\n\tconstructor(configuration: CompanionConfig, drama: Drama) {\n\t\tsuper(configuration);\n\t\tthis.drama = drama;\n\t\tthis.replyFunctions = [];\n\t\treturn this;\n\t}\n\n\tevaluateReplyTrigger = (replyTrigger: ReplyTriggerTypes | ReplyTriggerTypes[], context: Context, sender?: AutoCompanion): boolean => {\n\t\tif (replyTrigger == undefined) return sender == undefined;\n\t\tif (typeof replyTrigger == \"string\")\n\t\t\treturn replyTrigger == \"*\" ||\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// fallback reply\n\t\t\t\t(context.action == replyTrigger) || \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// filter for action\n\t\t\t\t(sender != undefined && replyTrigger.search(sender.id) > 0);\t\t\t\t\t\t\t\t\t\t// filter for sender name\n\t\tif (replyTrigger instanceof AutoCompanion) return sender != undefined && replyTrigger.id == sender.id;\t\t// filter for sender object\n\t\tif (typeof replyTrigger == \"function\") return replyTrigger(context, sender);\t\t\t\t\t\t\t\t// filter for callback function being true\n\t\tif (typeof replyTrigger == \"number\") return Math.random() <= replyTrigger;\t\t\t\t\t\t\t\t\t// random trigger\n\t\treturn replyTrigger.reduce<boolean>((previousValue, currentValue) => previousValue || this.evaluateReplyTrigger(currentValue, context, sender), false);\n\t}\n\n\tregisterReply = (trigger: ReplyTriggerTypes | ReplyTriggerTypes[], replyFunction: ReplyFunctionAsync, front: boolean = false) => {\n\t\tif (front) { // prepend\n\t\t\tthis.replyFunctions = [{ trigger: trigger, replyFunction: replyFunction }, ...this.replyFunctions];\n\t\t} else { // append\n\t\t\tthis.replyFunctions.push({ trigger: trigger, replyFunction: replyFunction })\n\t\t}\n\t}\n\n\tgenerateReply = async (chat: Chat, context: Context, sender?: AutoCompanion): Promise<Context> => {\n\n\t\tfor (const replyFunction of this.replyFunctions) {\n\t\t\tif (this.evaluateReplyTrigger(replyFunction.trigger, context, sender)) {\n\t\t\t\tconst [final, newContext] = await replyFunction.replyFunction(chat, context, this, sender);\n\t\t\t\tif (final) {\n\t\t\t\t\treturn newContext || context;\n\t\t\t\t} else {\n\t\t\t\t\tif (newContext)\n\t\t\t\t\t\tcontext = newContext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn context;\n\t}\n\n\trunInference = async (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply> => {\n\t\tconst deputyDecorators = context && sender && (sender as Deputy)?.decorators;\n\n\t\tconst newContext: Context = context || new Context(this, chat.companions, chat.id, chat.situation, []);\n\t\tconst input = chat.drama.getInput(this, chat.history, context, deputyDecorators);\n\n\t\tconst job: Job = {\n\t\t\tid: \"internal\",\n\t\t\tremoteID: \"\",\n\t\t\tstatus: \"new\",\n\t\t\tmodelConfig: this.configuration.modelConfig,\n\t\t\tprompt: typeof input === \"string\" ? input : undefined,\n\t\t\tmessages: typeof input !== \"string\" ? input : undefined,\n\t\t\tcontext: newContext,\n\t\t\ttimeStamp: Date.now()\n\t\t}\n\n\t\tconst jobResponse = await chat.drama.runJob(job);\n\n\t\tif (jobResponse && jobResponse.response) {\n\t\t\tjob.context.message = jobResponse.response;\n\t\t\treturn [true, job.context];\n\t\t}\n\n\t\treturn [false, job.context];\n\n\t}\n\n}","import { Chat } from \"../chat\";\nimport { largeContextModelConfig } from \"../config/models\";\nimport { Context } from \"../context\";\nimport { Drama } from \"../drama\";\nimport { Job } from \"../job\";\nimport { Messages } from \"../model\";\nimport { logger } from \"../utils/logging-utils\";\nimport { cleanText, findCut, getLastParagraph, getLastSentence, getRandomParagraph } from \"../utils/string-utils\";\nimport { AutoCompanion, CompanionReply } from \"./auto-companion\";\nimport { CompanionConfig } from \"./companion\";\n\n/**\n * Deputies are agents that companions can use for specific purposes. The user never interacts with a deputy directly.\n * @date 11/01/2024 - 14:45:47\n *\n * @export\n * @class Deputy\n * @typedef {Deputy}\n * @extends {AutoCompanion}\n */\nexport abstract class Deputy extends AutoCompanion {\n\n\t/**\n\t * Creates an instance of Deputy. Deputies can use a different prompter than companions in the chat.\n\t * @date 11/01/2024 - 14:45:47\n\t *\n\t * @constructor\n\t * @param {CompanionConfig} configuration\n\t * @param {?Prompter} [prompter]\n\t */\n\tconstructor(configuration: CompanionConfig, drama: Drama) {\n\t\tsuper(configuration, drama);\n\n\t\tswitch (configuration.scope) {\n\t\t\tcase \"screen\":\n\t\t\tcase \"some\": this.registerReply(\"*\", this.checkForSelection);\n\t\t\tcase \"document\": this.registerReply(this.wantsToSummarise, this.summariseDocumentInference, true); break;\n\t\t\tcase \"random_paragraph\": this.registerReply(\"*\", this.pickRandomParagraph, true); break;\n\t\t\tcase \"last_paragraph\": this.registerReply(\"*\", this.pickLastParagraph, true); break;\n\t\t\tcase \"last_sentence\": this.registerReply(\"*\", this.pickLastSentence, true); break;\n\t\t\tdefault: break;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\twantsToSummarise = (context: Context, sender?: AutoCompanion) => {\n\t\tconst document = context.query();\n\t\treturn document != undefined && document.trim().length >= 2000;\n\t};\n\n\tprotected abstract runAction(chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply>;\n\n\tprotected newDeputyJob = (input?: string | Messages, context?: Context, situation?: string) => {\n\t\tconst newContext: Context = context || new Context(this, [], \"\", situation || \"deputy\", []);\n\n\t\tconst inputData = { prompt: typeof input === \"string\" ? input : undefined, messages: typeof input !== \"string\" ? input : undefined };\n\n\t\tconst job: Job = {\n\t\t\tid: \"internal\",\n\t\t\tremoteID: \"\",\n\t\t\tstatus: \"new\",\n\t\t\tmodelConfig: this.configuration.modelConfig,\n\t\t\tcontext: newContext,\n\t\t\ttimeStamp: Date.now(),\n\t\t\t...inputData,\n\t\t}\n\n\t\treturn job;\n\n\t}\n\n\t// return \"true\" (== finished) if no selection\n\tprivate checkForSelection = async (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply> => {\n\t\tconst document = context.query();\n\t\tcontext.error = \"Not enough context\";\n\t\treturn [document == undefined || document.length == 0, context];\n\t}\n\n\tprotected pickRandomParagraph = async (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply> => {\n\t\tlogger.debug(\"pickRandomParagraph\", context)\n\n\t\tconst document = context.query();\n\t\tif (!document) return [false, undefined];\n\n\t\tcontext.text = getRandomParagraph(document);\n\t\tcontext.paragraph = undefined;\n\t\tcontext.input = undefined;\n\n\t\t// logger.debug(\"result: \" + context.text);\n\n\t\treturn [false, context];\n\t}\n\n\tprotected pickLastParagraph = async (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply> => {\n\t\tlogger.debug(\"pickLastParagraph\", context)\n\n\t\tconst document = context.query();\n\t\tif (!document) return [false, undefined];\n\n\t\tcontext.text = getLastParagraph(document);\n\t\tcontext.paragraph = undefined;\n\t\tcontext.input = undefined;\n\t\treturn [false, context];\n\t}\n\tprotected pickLastSentence = async (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply> => {\n\t\tlogger.debug(\"pickLastSentence\", context)\n\n\t\tconst document = context.query();\n\t\tif (!document) return [false, undefined];\n\n\t\tcontext.text = getLastSentence(document);\n\t\tcontext.paragraph = undefined;\n\t\tcontext.input = undefined;\n\t\treturn [false, context];\n\t}\n\t/*\n\t\t4 characters / token\n\t\t32k tokens -> 120k characters\n\n\t\t5.44 characters / word\n\t\t1,800 characters / page => 450 tokens / page\n\t*/\n\n\tprotected summariseDocumentInference = async (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply> => {\n\t\t// logger.debug(\"summariseDocumentInference\", { ...context })\n\n\t\tconst document = context.query();\n\t\tif (!document) return [false, undefined];\n\n\t\t// logger.debug(\"document\", document.substring(0, 250));\n\n\t\tlet trimmedDocument = cleanText(document.trim()); // cut off if too long\n\n\t\tif (trimmedDocument.length < 2000) {\n\t\t\t// no summary needed because already short enough\n\t\t\treturn [false, context];\n\t\t}\n\n\t\tif (trimmedDocument.length > 100000) {\n\t\t\t// we can only work with up to 120k characters so we cut this one into three 30k chunks\n\t\t\t// the first 40k, the last 40, and the 40k in the middle\n\n\t\t\tconst documentSize = trimmedDocument.length;\n\n\t\t\tconst shorter =\n\t\t\t\ttrimmedDocument.substring(0, findCut(trimmedDocument, 30000)) + \"\\n\\n\" +\n\t\t\t\ttrimmedDocument.substring(findCut(trimmedDocument, documentSize / 2 - 30000 / 2), findCut(trimmedDocument, documentSize / 2 + 30000 / 2)) + \"\\n\\n\" +\n\t\t\t\ttrimmedDocument.substring(findCut(trimmedDocument, documentSize - 30000));\n\n\t\t\ttrimmedDocument = shorter;\n\n\t\t\tlogger.debug(\"Gigantic document cut down from \" + documentSize + \" to \" + trimmedDocument.length + \" characters before summary.\");\n\t\t}\n\n\t\tconst tempContext: Context =\n\t\t\tnew Context(this, [], \"\", context.situation, [\n\t\t\t\t{ type: \"job\", data: \"Read the following document and reply with a one page summary.\" },\n\t\t\t\t{ type: \"action\", data: \"SUMMARISE_DOCUMENT\" },\n\t\t\t]);\n\n\t\t// use our own prompter. make the context short because we only want to send the last part of the dialog\n\t\t// const prompt = chat.drama.prompter.assemblePrompt(this, chat.drama.worldState, tempContext,\n\t\t// \t[{\n\t\t// \t\tcompanion: this.drama.companions.find(c => c.configuration.kind == \"user\") || this,\n\t\t// \t\tmessage: trimmedDocument,\n\t\t// \t\ttimeStamp: Date.now(),\n\t\t// \t }],\n\t\t// \tundefined,\n\t\t// \t{ max_prompt_length: 100000, job_in_chat: true });\n\n\t\tconst input = chat.drama.prompter.assemblePrompt(this, chat.drama.worldState, { ...tempContext, input: trimmedDocument },\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tlargeContextModelConfig.extra.promptConfig,\n\t\t\t(trimmedDocument.length > 30000) ? largeContextModelConfig.extra.template : undefined,\n\t\t\tthis.drama.chatMode);\n\n\t\tconst job = this.newDeputyJob(input, tempContext);\n\n\t\t// large model needed\n\t\tif (trimmedDocument.length > 30000) {\n\t\t\tjob.modelConfig = largeContextModelConfig;\n\t\t\tlogger.debug(\"Using large model\");\n\t\t}\n\n\t\ttry {\n\t\t\tconst jobResponse = await chat.drama.runJob(job);\n\t\t\tcontext.text = jobResponse!.response;\n\t\t\tcontext.paragraph = undefined;\n\t\t\tcontext.input = undefined;\n\n\t\t\t// logger.debug(\"summariseDocumentInference\", context)\n\n\t\t\treturn [false, context];\n\t\t} catch (e) {\n\t\t\tlogger.error(e);\n\t\t\treturn [true, undefined];\n\t\t}\n\n\n\t}\n\n\n}","import { Chat, ChatMessage } from \"../chat\";\nimport { Context } from \"../context\";\nimport { Drama } from \"../drama\";\nimport { getRandomElement } from \"../utils/array-utils\";\nimport { logger } from \"../utils/logging-utils\";\nimport { AutoCompanion, CompanionReply } from \"./auto-companion\";\nimport { Companion, CompanionConfig } from \"./companion\";\nimport { Deputy } from \"./deputy\";\n\n\nexport class ModeratorDeputy extends Deputy {\n\n\tstatic config: CompanionConfig = {\n\t\tname: \"JeanLuc\",\n\t\tclass: ModeratorDeputy,\n\t\tdescription: \"This is an internal bot for instruction-based inferences.\",\n\t\tbase_prompt: \"\",\n\t\tkind: \"shell\",\n\t\ttemperature: 0,\n\t}\n\n\tconstructor(configuration: CompanionConfig = ModeratorDeputy.config, drama: Drama) {\n\t\tsuper(configuration, drama);\n\t\treturn this;\n\t}\n\n\tprotected runAction = async (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply> => {\n\t\t// this bot is meant to be run manually for now\n\t\treturn [false, undefined];\n\t}\n\n\t/**\n\t * Prologue before pick speaker prompt.\n\t * @date 12/01/2024 - 12:51:23\n\t */\n\tselectSpeakerPrologue = (chat: Chat, speakers: Companion[], username: string) => {\n\t\tconst promptPrefix = `\nYou are a moderator in an online chatroom. You are provided with a list of online users with their bios under ## ROLES ##. In addition, you have access to their conversation history under ## CONVERSATION ## where you can find the previous exchanges between different users.\n\nYour task is to read the history in ## CONVERSATION ## and then select which of the ## ROLES ## should speak next. You MUST only return a single name as your response.\n`\n\n\t\tconst promptRoles = `\n## ROLES ##\n\n${speakers.filter(c => c.configuration.kind == \"npc\").map(c => c.configuration.name + \": \" + c.configuration.description).join(\"\\n\")}\n${username}: A guest user in the chatroom.\n\n## END OF ROLES ##\n\n## CONVERSATION ##\n`\n\t\treturn promptPrefix + promptRoles;\n\t\t// return \"You are in a role-playing game. The following roles are available:\\n\"\n\t\t// \t+ chat.companions.filter(c => c.configuration.kind == \"npc\").map(c => c.id + \": \" + c.configuration.description).join(\"\\n\")\n\t\t// \t+ \"\\nRead the following conversation.\\nThen select the next role from \"\n\t\t// \t+ speakers.map(c => c.id).join(\", \")\n\t\t// \t+ \" to play. Only return the role.\"\n\t}\n\n\t/**\n\t * Use the speakerSelection to pick the next speaker(s)\n\t * @date 12/01/2024 - 12:51:23\n\t *\n\t * @async\n\t */\n\tselectSpeakers = async (chat: Chat, context: Context, lastSpeaker?: AutoCompanion, except?: Companion[], messages?: ChatMessage[]) => {\n\n\t\tconst companions = chat.companions;\n\t\tif (companions.length == 1) return [companions[0]];\n\n\t\tlogger.debug(\"In speaker selection\");\n\n\t\tconst nextSpeaker = context.recipient;\n\t\tif (nextSpeaker) {\n\t\t\tconst deputy = context.findDelegate(nextSpeaker.configuration, chat.drama.companions);\n\n\t\t\t// if there's a specified next speaker and a deputy, return chain\n\t\t\tif (deputy) return [nextSpeaker, deputy];\n\t\t}\n\n\t\t// if there's a nextSpeaker set just return it\n\t\tif (nextSpeaker) return [nextSpeaker];\n\n\t\t// ry to set last speaker if undefined\n\t\tif (lastSpeaker == undefined && chat.history.length > 0) {\n\t\t\tlastSpeaker = chat.history.sort((l, r) => l.timeStamp - r.timeStamp)[chat.history.length - 1].companion;\n\t\t}\n\n\t\t// filter user and last speaker from message list\n\t\tconst allowedSpeakers = (except == undefined ? companions : companions.filter(c => except.find(e => e.id == c.id) == undefined)).filter(c => c.configuration.kind != \"shell\");\n\t\tconst speakers = (chat.allowRepeatSpeaker || lastSpeaker == undefined) ? allowedSpeakers : allowedSpeakers.filter(c => (lastSpeaker != undefined) && (c.id != lastSpeaker.id));\n\t\tconst you = chat.companions.find(c => c.configuration.kind == \"user\");\n\n\t\tlogger.debug(\"lastSpeaker: \", lastSpeaker);\n\t\tlogger.debug(\"allowedSpeakers: \", speakers);\n\n\t\tif (speakers.length == 1)\n\t\t\treturn [speakers[0]];\n\n\t\t// Check if any person was mentioned. This overrides everything.\n\t\tif (chat.history.length > 0) {\n\t\t\tconst mentionedSpeakers = chat.mentionedCompanions(chat.history[chat.history.length - 1].message).filter(m => speakers.includes(m));\n\t\t\tif (mentionedSpeakers.length > 0) {\n\t\t\t\tlogger.debug(\"mentionedSpeakers: \", mentionedSpeakers);\n\t\t\t\t// insert the person who mentioned someone after all the mentioned\n\t\t\t\treturn (lastSpeaker && !mentionedSpeakers.includes(lastSpeaker)) ? [lastSpeaker, ...mentionedSpeakers] : mentionedSpeakers;\n\t\t\t}\n\t\t}\n\n\t\tconst selectedSpeaker =\n\t\t\t(chat.speakerSelection == \"round_robin\" && lastSpeaker) ? chat.nextCompanion(lastSpeaker, speakers.filter(s => s.configuration.kind == \"npc\")) as AutoCompanion :\n\t\t\t\tchat.speakerSelection == \"random\" ? getRandomElement(speakers) as AutoCompanion :\n\t\t\t\t\tundefined;\n\n\t\tlogger.debug(\"speakerSelection: \" + chat.speakerSelection)\n\t\tselectedSpeaker && logger.debug(\"Next speaker: \" + selectedSpeaker?.id)\n\n\t\tif (selectedSpeaker) return [selectedSpeaker];\n\n\t\t// we need a chat history from here\n\t\tif (!messages) return [getRandomElement(speakers)] as [AutoCompanion];\n\n\t\tconst username = chat.drama.worldState.find(w => w.key == \"USERNAME\")?.value as string || \"user\";\n\n\t\tconst chatHistory = messages\n\t\t\t.filter(m => m.companion.configuration.kind != \"shell\")\n\t\t\t.slice(-8)\n\t\t\t.map(m => (m.companion.id == \"you\") ? username + \": \" + m.message.trim() : m.companion.configuration.name + \": \" + m.message.trim())\n\t\t\t.join(\"\\n\");\n\n\t\tconst newContext: Context =\n\t\t\tnew Context(this, [], \"\", chat.situation, [\n\t\t\t\t{ type: \"persona\", data: this.selectSpeakerPrologue(chat, speakers, username) },\n\t\t\t\t{ type: \"chat\", data: chatHistory },\n\t\t\t\t{ type: \"action\", data: \"SELECT_SPEAKER\" },\n\t\t\t\t{ type: \"epilogue\", data: \"\\n## END OF CONVERSATION ##\" }\n\t\t\t]);\n\n\t\t// use our own prompter. make the context short because we only want to send the last part of the dialog\n\t\tconst input = chat.drama.prompter.assemblePrompt(this,\n\t\t\tchat.drama.worldState, newContext, undefined, undefined, undefined, undefined, this.drama.chatMode);\n\n\t\tconst job = this.newDeputyJob(input, newContext);\n\t\t// if (job.modelConfig) {\n\t\t// \tjob.modelConfig.max_tokens = 25;\n\t\t// \tjob.modelConfig.temperature = 0.2;\n\t\t// }\n\n\t\ttry {\n\t\t\tconst jobResponse = await chat.drama.runJob(job);\n\n\t\t\tif (jobResponse && jobResponse.response) {\n\n\t\t\t\tconst mentionedCompanions = chat.mentionedCompanions(jobResponse.response);\n\n\t\t\t\t(mentionedCompanions.length > 0) ?\n\t\t\t\t\tlogger.debug(\"Auto speakers: \" + mentionedCompanions.map(c => c.configuration.name).join(\", \"))\n\t\t\t\t\t:\n\t\t\t\t\tlogger.debug(\"Auto speakers response: \" + jobResponse.response);\n\n\t\t\t\tconst allowedMentioned = mentionedCompanions.filter(c => speakers.includes(c));\n\n\t\t\t\tif (allowedMentioned.length >= 1) return allowedMentioned.reverse();\n\t\t\t}\n\n\t\t} catch (e) {\n\t\t\tlogger.error(e);\n\t\t}\n\n\t\t// disabling repeat speakers because why would I want that?\n\t\t// // fallback: if there was a previous npc speaker pick them\n\t\t// const lastNPC = chat.history.findLast(e => e.companion.configuration.kind == 'npc')?.companion;\n\t\t// if (lastNPC) return [lastNPC];\n\n\t\t// otherwise pick a random respondent\n\t\treturn [getRandomElement(speakers)] as [AutoCompanion];\n\t}\n\n\n\n}","import { AutoCompanion } from \"./companions/auto-companion\";\nimport { Companion } from \"./companions/companion\";\nimport { ModeratorDeputy } from \"./companions/moderator-deputy\";\nimport { Context } from \"./context\";\nimport { Drama } from \"./drama\";\nimport { logger } from \"./utils/logging-utils\";\n\n/**\n * Determine how the next speaker is chosen.\n * @export\n * @typedef {ChatSpeakerSelection}\n */\nexport type ChatSpeakerSelection = \"auto\" | \"random\" | \"round_robin\";\n/**\n * One entry in a chat history. Often called message\n * @export\n * @typedef {ChatMessage}\n */\nexport type ChatMessage = { companion: AutoCompanion, message: string, timeStamp: number, context?: Context };\n\n/**\n * The chat class holds one conversation. Chat participants are companions from drama. One chat is one conversation.\n * @export\n * @class Chat\n * @typedef {Chat}\n */\nexport class Chat {\n\t/**\n\t * A unique id\n\t * @type {string}\n\t */\n\treadonly id: string;\n\t/**\n\t * For distinguishing behaviour according to the situation (see CompanionConfig). E.g. \"writersroom\"\n\t * @type {string}\n\t */\n\treadonly situation: string;\n\t/**\n\t * References to all companions in this chat.\n\t * @type {AutoCompanion[]}\n\t */\n\tcompanions: AutoCompanion[];\n\t/**\n\t * The chat should end after this many rounds. Not implemented.\n\t * @type {number}\n\t */\n\tmaxRounds: number;\n\t/**\n\t * Determines how the next speaker is chosen.\n\t * @type {ChatSpeakerSelection}\n\t */\n\tspeakerSelection: ChatSpeakerSelection;\n\t/**\n\t * The message history of this chat.\n\t * @type {ChatMessage[]}\n\t */\n\thistory: ChatMessage[];\n\t/**\n\t * Determines whether a speaker can be selected twice in a row.\n\t * @type {boolean}\n\t */\n\tallowRepeatSpeaker: boolean = false;\n\t/**\n\t * The drama this chat is a part of.\n\t * @type {Drama}\n\t */\n\treadonly drama: Drama;\n\t/**\n\t * The chat's moderator.\n\t * @type {ModeratorDeputy}\n\t */\n\tmoderator: ModeratorDeputy;\n\t/**\n\t * The active context if state has to be preserved\n\t * @type {(Context | undefined)}\n\t */\n\tcurrentContext: Context | undefined;\n\n\t/**\n\t * Creates an instance of Chat.\n\t * @date 12/01/2024 - 12:51:23\n\t *\n\t * @constructor\n\t * @param {Drama} drama\n\t * @param {string} id\n\t * @param {string} [situation=\"fireplace\"]\n\t * @param {AutoCompanion[]} companions\n\t * @param {number} [maxRounds=8]\n\t * @param {ChatSpeakerSelection} [speakerSelection=\"random\"]\n\t */\n\tconstructor(drama: Drama, id: string, situation = \"fireplace\", companions: AutoCompanion[], maxRounds: number = 8, speakerSelection: ChatSpeakerSelection = \"random\" ) {\n\t\tthis.id = id;\n\t\tthis.situation = situation;\n\t\tthis.drama = drama;\n\t\tthis.companions = companions;\n\t\tthis.maxRounds = maxRounds;\n\t\tthis.speakerSelection = speakerSelection;\n\t\tthis.history = [];\n\t\tthis.moderator = new ModeratorDeputy(ModeratorDeputy.config, drama);\n\n\t\tthis.createDeputies();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Create all deputies that the companions reference in actions\n\t * @date 17/01/2024 - 10:25:19\n\t */\n\tprotected createDeputies = () => {\n\t\tthis.companions\n\t\t\t.filter(c => c.configuration.kind == \"npc\")\n\t\t\t.forEach(c => c.configuration.actions?.forEach(a => {\n\t\t\t\tconst deputy = this.drama.companions.find(c => c.id == a.deputy);\n\n\t\t\t\tif (!deputy) {\n\t\t\t\t\tlogger.error(\"Error: Can't find deputy: \" + a.deputy);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this.companions.includes(deputy)) {\n\t\t\t\t\t// logger.debug(\"Auto-adding deputy: \" + a.deputy);\n\t\t\t\t\tthis.companions.push(deputy);\n\t\t\t\t}\n\t\t\t}))\n\n\t}\n\n\t/**\n\t * Delete all messages in this chat.\n\t * @date 12/01/2024 - 12:51:23\n\t */\n\tclearMessages = () => { this.history = [] }\n\t/**\n\t * Add a message.\n\t * @date 12/01/2024 - 12:51:23\n\t */\n\tappendMessage = (companion: AutoCompanion, message: string, context?: Context) => {\n\t\tlogger.debug(companion.id + \": \" + message);\n\t\tconst appendedMessage = { companion: companion, message: message, timeStamp: Date.now(), context: context ? { ...context } : undefined };\n\t\tthis.history.push(appendedMessage);\n\t\tcompanion.interactions++;\n\t\treturn appendedMessage;\n\t}\n\t/**\n\t * Add a message.\n\t * @date 12/01/2024 - 12:51:23\n\t */\n\tmoderatorMessage = (message: string, context?: Context) => {\n\t\tconst appendedMessage = { companion: this.moderator, message: message, timeStamp: Date.now(), context: context ? { ...context } : undefined };\n\t\tthis.history.push(appendedMessage);\n\t\treturn appendedMessage;\n\t}\n\t/**\n\t * Get the last message (or undefined if there is none)\n\t * @date 12/01/2024 - 12:51:23\n\t */\n\tlastMessage = () => {\n\t\treturn this.history.length > 0 ? this.history[this.history.length - 1] : undefined;\n\t}\n\n\t/**\n\t * Selected the next companion in a list.\n\t * @date 12/01/2024 - 12:51:23\n\t */\n\tnextCompanion = (companion: AutoCompanion, companions: AutoCompanion[]) => {\n\t\tconst index = this.companions.findIndex((c) => c.id == companion.id);\n\n\t\tif (companions == this.companions) {\n\t\t\treturn companions[(index + 1) % companions.length];\n\t\t}\n\n\t\tconst offset = index + 1;\n\t\tfor (let i = 0; i < companions.length; ++i) {\n\t\t\tif (companions.includes((this.companions[(offset + i) % this.companions.length])))\n\t\t\t\treturn this.companions[(offset + i) % this.companions.length];\n\t\t}\n\n\t\treturn companion;\n\t}\n\t/**\n\t * Return a list of all mentioned companions.\n\t * @date 12/01/2024 - 12:51:23\n\t */\n\tmentionedCompanions = (text: string) => {\n\t\treturn this.companions.filter(c => c.configuration.kind == \"npc\" && (text.includes(c.id) || text.includes(c.configuration.name)));\n\t}\n\t/**\n\t * Return the companion object representing the user.\n\t * @date 12/01/2024 - 12:51:23\n\t * @returns {AutoCompanion}\n\t */\n\tuserCompanion = () => this.companions.find(c => c.configuration.kind == \"user\");\n\n\t/**\n\t * Use the value in speakerSelection to pick the next speaker(s). Executed in the moderator deputy.\n\t * \"auto\": Use an inference to pick the right next speaker(s)\n\t * \"random\": Pick a random next speaker.\n\t * \"round_robin\"; Pick the next speaker in the list.\n\t * Falls back to \"random\" if the specified selection does not yield a valid result.\n\t *\n\t * @date 17/01/2024 - 13:39:19\n\t *\n\t * @async\n\t * @param {AutoCompanion?} lastSpeaker The last speaker (who will not speak again unless allowRepeatSpeaker is true).\n\t * @param {Companion[]?} except Prevent the system from picking from this list.\n\t * @returns {AutoCompanion[]}\n\t */\n\tselectSpeakers = async (context: Context, lastSpeaker?: AutoCompanion, except?: Companion[]) => {\n\t\treturn await this.moderator.selectSpeakers(this, context, lastSpeaker, except, this.history);\n\t}\n}","import { Drama } from \"../drama\";\nimport { AutoCompanion, CompanionReply } from \"./auto-companion\";\nimport { CompanionConfig } from \"./companion\";\n\n/**\n * This class is for our AI chat companions\n * - Adds an automatic reply function that triggers and inference\n */\n\nexport class ChatCompanion extends AutoCompanion {\n\n\tconstructor(configuration: CompanionConfig, drama: Drama) {\n\t\tsuper(configuration, drama);\n\t\t// this.replyFunctions.push({ trigger: \"*\", replyFunction: this.moodChange });\n\t\tthis.replyFunctions.push({ trigger: \"*\", replyFunction: this.runInference });\n\t\treturn this;\n\t}\n\n\t// moodChange = async (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply> => {\n\t// \tif (this.mood.label != \"neutral\")\n\t// \t\tcontext.mood = this.mood.prompt;\n\t// \treturn [false, context];\n\t// }\n\n}","import { Chat, ChatMessage } from \"../chat\";\nimport { Context } from \"../context\";\nimport { Drama } from \"../drama\";\nimport { AutoCompanion, CompanionReply } from \"./auto-companion\";\nimport { CompanionConfig } from \"./companion\";\nimport { Deputy } from \"./deputy\";\n\n\nexport class InstructionDeputy extends Deputy {\n\n\tstatic readonly config: CompanionConfig = {\n\t\tname: \"Barclay\",\n\t\tclass: InstructionDeputy,\n\t\tdescription: \"This deputy sets a job for the companion to act out.\",\n\t\tbase_prompt: \"\",\n\t\tkind: \"shell\",\n\t\ttemperature: 0,\n\t}\n\n\tconstructor(configuration: CompanionConfig = InstructionDeputy.config, drama: Drama) {\n\t\tsuper(configuration, drama);\n\t\tthis.replyFunctions.push({ trigger: \"*\", replyFunction: this.runAction })\n\t\treturn this;\n\t}\n\n\tprotected runAction = async (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply> => {\n\t\t\n\t\tconst input = context.query();\n\t\tif (!input || input.length < 5) { \n\t\t\tcontext.job = \"Explain your purpose to the user and that the user has to select some text before you can do your job.\";\n\t\t\treturn [true, context];\n\t\t}\n\t\t\n\t\tcontext.job = this.configuration.job;\n\t\t// this.configuration.job && context.persona = \"\";\n\t\t// Can't remove the persona as then the situation would be used and we don't want that, do we Hal?\n\t\treturn [true, context];\n\t}\n\n\n}\n","import { Chat } from \"../chat\";\nimport { Context } from \"../context\";\nimport { Drama } from \"../drama\";\nimport { logger } from \"../utils/logging-utils\";\nimport { AutoCompanion, CompanionReply } from \"./auto-companion\";\nimport { CompanionConfig } from \"./companion\";\nimport { Deputy } from \"./deputy\";\n\n\nexport class TestDeputy extends Deputy {\n\n\tstatic readonly config: CompanionConfig = {\n\t\tname: \"Kirk\",\n\t\tclass: TestDeputy,\n\t\tdescription: \"Just for testing\",\n\t\tbase_prompt: \"\",\n\t\tkind: \"shell\",\n\t\ttemperature: 0,\n\t}\n\n\tconstructor(configuration: CompanionConfig = TestDeputy.config, drama: Drama) {\n\t\tsuper(configuration, drama);\n\t\tthis.replyFunctions.push({ trigger: \"*\", replyFunction: this.runAction })\n\t\treturn this;\n\t}\n\n\tprotected runAction = async (chat: Chat, context: Context, recipient?: AutoCompanion, sender?: AutoCompanion): Promise<CompanionReply> => {\n\n\t\t// const firstAction = this.configuration.actions?.at(0);\n\t\t// const delegate = firstAction && chat.companions.find(c => c.id == firstAction.deputy);\n\n\t\t// if there's a delegate and no answer yet just forward\n\t\t// const delegate = context.findDelegate(this.configuration, chat.companions);\n\t\t// if (delegate && !context.hasAnswer()) return [true, context];\n\n\t\t// do nothing\n\t\tlogger.debug(\"TEST DELEGATE CONTEXT\", context);\n\n\t\t// otherwise we're done\n\t\treturn [true, context];\n\t}\n\n\n}","/* In-memory database to act as a default database for tracking interactions with the Drama Engine. Replace with \n * a localStorage-based system if you want to persist sessions in the browser.\n */\n\nimport { ChatMessage, ChatRecord, Companion, Database, KeyValueRecord, PromptRecord, StateTypes } from \"..\";\n\nexport class InMemoryDatabase implements Database {\n    private companions: Companion[] = [];\n    private worldState: Record<string, StateTypes> = {};\n    private promptEntries: PromptRecord[] = [];\n    private chatEntries: Record<string, ChatRecord> = {};\n\n    async reset(): Promise<void> {\n        this.companions = [];\n        this.worldState = {};\n        this.promptEntries = [];\n        this.chatEntries = {};\n    }\n\n    async initCompanionStats(companions: Companion[]): Promise<void> {\n        this.companions = companions;\n    }\n\n    async world(): Promise<KeyValueRecord[]> {\n        return Object.entries(this.worldState).map(([key, value]) => ({ key, value }));\n    }\n\n    async setWorldStateEntry(key: string, value: StateTypes): Promise<void> {\n        this.worldState[key] = value;\n    }\n\n    async prompts(): Promise<PromptRecord[]> {\n        return this.promptEntries;\n    }\n\n    async addPromptEntry(record: PromptRecord): Promise<void> {\n        this.promptEntries.push(record);\n    }\n\n    async chats(): Promise<ChatRecord[]> {\n        return Object.values(this.chatEntries);\n    }\n\n    async getChat(chatID: string): Promise<ChatRecord | undefined> {\n        return this.chatEntries[chatID];\n    }\n\n    async deleteChat(chatID: string): Promise<void> {\n        delete this.chatEntries[chatID];\n    }\n\n    async writeChat(id: string, history: ChatMessage[]): Promise<string> {\n        this.chatEntries[id] = {\n            id: id,\n            history: history.filter(h => h.companion.configuration.kind == \"npc\" || h.companion.configuration.kind == \"user\").map(h => { return { companion: h.companion.configuration.name, message: h.message, timeStamp: h.timeStamp } })\n        };\n        return id;\n    }\n\n    async overwriteChats(items: ChatRecord): Promise<string> {\n        this.chatEntries[items.id] = items;\n        return items.id;\n    }\n}\n","import ky, { KyInstance, Options } from \"ky\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { Chat, ChatMessage, ChatSpeakerSelection } from \"./chat\";\nimport { AutoCompanion } from \"./companions/auto-companion\";\nimport { ChatCompanion } from \"./companions/chat-companion\";\nimport { ActionDescription, Companion, CompanionConfig } from \"./companions/companion\";\nimport { evaluateCondition } from \"./conditions\";\nimport { PromptConfig } from \"./config/prompts\";\nimport { Context, ContextDecorator } from \"./context\";\nimport { ChatRecord, Database, HistoryRecord, KeyValueRecord, StateTypes } from \"./db/database\";\nimport { Job, JobStatus } from \"./job\";\nimport { Model } from \"./model\";\nimport { Prompter } from \"./prompter\";\nimport { logger } from \"./utils/logging-utils\";\nimport { KyHeadersInit } from \"ky/distribution/types/options\";\nimport { InMemoryDatabase } from \"./db/in-memory-database\";\n\nexport class Drama {\n\tmodel: Model;\n\tinstance: KyInstance;\n\tdatabase: Database;\n\tadditionalOptions?: Options;\n\tprompter: Prompter;\n\tchatMode: boolean;\n\n\tcompanions: AutoCompanion[] = [];\n\tworldState: KeyValueRecord[] = [];\n\tjobs: Job[] = [];\n\tchats: Chat[] = [];\n\n\tprivate constructor(\n\t\tcompanionConfigs: CompanionConfig[],\n\t\tdatabase: Database,\n\t\tworldState: KeyValueRecord[],\n\t\tkyInstance: KyInstance,\n\t\tadditionalOptions?: Options,\n\t\tchatModeOverride?: boolean,\n\t) {\n\t\tthis.worldState = worldState;\n\n\t\tconst apiEndpoint = process.env.DE_ENDPOINT_URL || process.env.NEXT_PUBLIC_DE_ENDPOINT_URL || 'v1/completions';\n\t\tthis.chatMode = chatModeOverride === undefined ? apiEndpoint.includes('chat/completions') : chatModeOverride;\n\n\t\tthis.model = new Model(apiEndpoint);\n\t\tthis.prompter = new Prompter(this.model.promptTemplate);\n\t\tthis.instance = kyInstance;\n\t\tthis.database = database;\n\t\tthis.additionalOptions = additionalOptions;\n\t\tthis.companions = companionConfigs.map(c => new c.class(c, this));\n\n\t\tlogger.info(\"DRAMA ENGINE // INITIATED\");\n\n\t\treturn this;\n\t}\n\n\tprivate static isAuthTokenAvailable(headersInit?: KyHeadersInit): boolean {\n\t\tif (headersInit) {\n\t\t\tconst headers = new Headers(headersInit as HeadersInit);\n\n\t\t\tconst authHeaderExists = (headers?.get(\"authorization\")?.length || 0) > 0;\n\t\t\tconst apiKeyHeaderExists = (headers?.get(\"x-api-key\")?.length || 0) > 0;\n\t\t\tconst authTokenHeaderExists = (headers?.get(\"x-auth-token\")?.length || 0) > 0;\n\n\t\t\treturn authHeaderExists || apiKeyHeaderExists || authTokenHeaderExists;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static checkAdditionalOptions(additionalOptions?: Options): Options {\n\t\tlet additionalOptionsWithPrefix: Options = additionalOptions || {};\n\n\t\tif (additionalOptionsWithPrefix?.prefixUrl === undefined) {\n\t\t\tadditionalOptionsWithPrefix = {\n\t\t\t\tprefixUrl: process.env.DE_BASE_URL || process.env.NEXT_PUBLIC_DE_BASE_URL || \"\",\n\t\t\t\t...additionalOptionsWithPrefix,\n\t\t\t};\n\t\t}\n\n\t\tconst authTokenAvailable = this.isAuthTokenAvailable(additionalOptions?.headers);\n\n\t\tif (!authTokenAvailable) {\n\t\t\tlet apiKey = process.env.DE_BACKEND_API_KEY;\n\t\t\tif (!apiKey) {\n\t\t\t\tapiKey = process.env.NEXT_PUBLIC_DE_BACKEND_API_KEY;\n\t\t\t\tif (apiKey) {\n\t\t\t\t\tlogger.warn(\"API key was found in a publicly exposed variable, `NEXT_PUBLIC_DE_BACKEND_API_KEY`. Ensure this was intended behaviour.\");\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\"No API keys were found. Checked the following headers: Authorization, X-API-KEY, X-Auth-Token. And the following variables: DE_BACKEND_API_KEY, NEXT_PUBLIC_DE_BACKEND_API_KEY. Ensure this was intended behaviour.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tadditionalOptionsWithPrefix = {\n\t\t\t\t...additionalOptionsWithPrefix,\n\t\t\t\theaders: {\n\t\t\t\t\t...(apiKey ? {\n\t\t\t\t\t\t'Authorization': `Bearer ${apiKey}`,\n\t\t\t\t\t} : {}),\n\t\t\t\t\t...additionalOptionsWithPrefix?.headers,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn additionalOptionsWithPrefix;\n\t}\n\n\tstatic async initialize(defaultSituation: string,\n\t\tcompanionConfigs: CompanionConfig[],\n\t\tkyInstance: KyInstance = ky,\n\t\tdatabase: Database = new InMemoryDatabase(),\n\t\tadditionalOptions?: Options,\n\t\tchatModeOverride?: boolean,\n\t) {\n\t\tconst worldState = await database.world() || [];\n\t\tconst newAdditionalOptions: Options = this.checkAdditionalOptions(additionalOptions);\n\n\t\t// Add the user if there is none\n\t\tif (!companionConfigs.find(c => c.kind == \"user\"))\n\t\t\tcompanionConfigs = [\n\t\t\t\t...companionConfigs,\n\t\t\t\t{\n\t\t\t\t\tname: \"You\",\n\t\t\t\t\tclass: ChatCompanion,\n\t\t\t\t\tbio: \"The user\",\n\t\t\t\t\tdescription: \"The user of this app. A person who seeks companionship.\",\n\t\t\t\t\tbase_prompt: \"\",\n\t\t\t\t\tavatar: \"/img/avatar-user.jpg\",\n\t\t\t\t\tkind: \"user\",\n\t\t\t\t},\n\t\t\t];\n\n\t\tconst drama = new Drama(companionConfigs, database, worldState, kyInstance, newAdditionalOptions, chatModeOverride);\n\n\t\t// load interactions counters\n\t\tdrama.companions.forEach(companion => {\n\n\t\t\tconst interactions = worldState.find(w => w.key == \"COMPANION_INTERACTIONS_\" + companion.id.toUpperCase());\n\t\t\tif (interactions && typeof interactions.value == \"number\")\n\t\t\t\tcompanion.interactions = interactions.value;\n\n\t\t\tconst actions = worldState.find(w => w.key == \"COMPANION_ACTIONS_\" + companion.id.toUpperCase());\n\t\t\tif (actions && typeof actions.value == \"number\")\n\t\t\t\tcompanion.actions = actions.value;\n\n\t\t\t// every NPC companion gets a chat and a mood\n\t\t\tif (companion.configuration.kind == \"npc\") {\n\t\t\t\tif (companion.configuration.moods) {\n\t\t\t\t\tlet rnd = Math.random();\n\n\t\t\t\t\tconst mood = companion.configuration.moods\n\t\t\t\t\t\t.sort((l, r) => l.probability - r.probability)\n\t\t\t\t\t\t.find(m => {\n\t\t\t\t\t\t\tif (rnd - m.probability <= 0) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trnd -= m.probability;\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\n\t\t\t\t\tif (mood) {\n\t\t\t\t\t\tcompanion.mood.label = mood.label;\n\t\t\t\t\t\tcompanion.mood.prompt = mood.prompt;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdrama.addCompanionChat(companion, defaultSituation);\n\t\t\t}\n\t\t})\n\n\t\treturn drama;\n\t}\n\n\treset = async () => {\n\t\tlogger.info(\"DRAMA ENGINE // RESET\");\n\n\t\tthis.jobs = [];\n\t\tawait this.database.reset();\n\t\tawait this.database.initCompanionStats(this.companions);\n\t}\n\n\t/* WORLD STATE MANAGEMENT */\n\n\tincreaseWorldStateEntry = async (key: string, value: number) => {\n\t\tconst ws = this.worldState.find(s => s.key == key);\n\t\tif (ws) {\n\t\t\tws.value = (ws.value as number) + value;\n\t\t} else {\n\t\t\tthis.worldState.push({ key, value });\n\t\t}\n\t\tawait this.database.setWorldStateEntry(key, ws?.value || value);\n\t}\n\tsetWorldStateEntry = async (key: string, value: StateTypes) => {\n\t\tconst ws = this.worldState.find(s => s.key == key);\n\t\tif (ws) {\n\t\t\tws.value = value;\n\t\t} else {\n\t\t\tthis.worldState.push({ key: key, value: value });\n\t\t}\n\t\tawait this.database.setWorldStateEntry(key, value);\n\t}\n\tgetWorldStateValue = (key: string): StateTypes | undefined => {\n\t\treturn this.worldState.find(s => s.key == key)?.value;\n\t}\n\n\tlogInteraction = (companion: Companion) => {\n\t\tconst cmp = this.companions.find((c) => c.id == companion.id);\n\t\tcmp && cmp.interactions++;\n\t}\n\tlogAction = (companion: Companion) => {\n\t\tconst cmp = this.companions.find((c) => c.id == companion.id);\n\t\tcmp && cmp.interactions++;\n\t}\n\n\tsyncInteractions = async () => {\n\t\tlet allInteractions = 0;\n\t\tfor (const companion of this.companions) {\n\t\t\tawait this.setWorldStateEntry(\"COMPANION_INTERACTIONS_\" + companion.id.toUpperCase(), companion.interactions);\n\t\t\tawait this.setWorldStateEntry(\"COMPANION_ACTIONS_\" + companion.id.toUpperCase(), companion.actions);\n\t\t\tallInteractions += companion.interactions;\n\t\t}\n\n\t\tawait this.setWorldStateEntry(\"COMPANION_INTERACTIONS\", allInteractions);\n\t}\n\n\tgetActiveActions = () => {\n\t\tconst q: { companion: AutoCompanion, action: ActionDescription }[] = [];\n\n\t\tthis.companions\n\t\t\t.filter(companion => companion.configuration.kind == \"npc\" && companion.configuration.actions)\n\t\t\t.forEach((companion) => {\n\t\t\t\tif (!companion.configuration.actions) return;\n\n\t\t\t\t// copy all actions that are active. don't sort for now.\n\t\t\t\tq.push(\n\t\t\t\t\t...companion.configuration.actions\n\t\t\t\t\t\t.filter(action => action.label && (!action.condition || evaluateCondition(action.condition, this.worldState)))\n\t\t\t\t\t\t.map(a => { return { companion: companion, action: a } })\n\t\t\t\t)\n\t\t\t})\n\n\t\treturn q;\n\t}\n\n\t/* JOBS */\n\n\tpushJob = async (context: Context) => {\n\t\tconst id = uuidv4();\n\t\tconst job: Job = {\n\t\t\tid: id,\n\t\t\tstatus: \"new\",\n\t\t\tcontext: context,\n\t\t\tremoteID: \"\",\n\t\t\ttimeStamp: Date.now(),\n\t\t}\n\n\t\tlogger.debug(\"new job: \", job);\n\n\t\tthis.jobs.push(job);\n\t}\n\n\tsetJobState = (id: string, state: JobStatus) => {\n\t\tconst index = this.jobs.findIndex(j => j.id == id);\n\t\tthis.jobs[index] = { ...this.jobs[index], status: state }\n\t}\n\n\tsetJobRemoteID = (id: string, remoteID: string) => {\n\t\tconst index = this.jobs.findIndex(j => j.id == id);\n\t\tthis.jobs[index] = { ...this.jobs[index], remoteID: remoteID }\n\t}\n\n\tgetJobsByState = (state: JobStatus) => {\n\t\treturn this.jobs\n\t\t\t.filter((j) => j.status == state)\n\t\t\t.sort((l, r) => r.timeStamp - l.timeStamp)\n\t}\n\n\tremoveJob = (id: string) => {\n\t\tthis.jobs = this.jobs.filter(j => j.id != id);\n\t}\n\n\t/* PROMPT */\n\n\tgetInput = (companion: Companion, history: ChatMessage[], context: Context, decorators: ContextDecorator[] = [], config: PromptConfig = this.model.promptConfig) => {\n\t\treturn this.prompter.assemblePrompt(companion, this.worldState, context, history, decorators, config, undefined, this.chatMode);\n\t}\n\n\t/* INFERENCES */\n\n\trunJob = async (job: Job) => {\n\t\tconst response = await this.model.runJob(job, this.instance, this.additionalOptions);\n\t\tresponse && job.context.addUsage(response);\n\n\t\tlogger.debug(\"runJob\", job, \"-->\", response);\n\n\t\tawait this.increaseWorldStateEntry(\"INPUT_TOKENS\", job.context.input_tokens);\n\t\tawait this.increaseWorldStateEntry(\"OUTPUT_TOKENS\", job.context.output_tokens);\n\n\t\tif (job.context.action && job.context.recipient)\n\t\t\tawait this.increaseWorldStateEntry(\"COMPANION_ACTIONS_\" + job.context.recipient.id.toUpperCase(), 1);\n\n\t\tawait this.database.addPromptEntry({\n\t\t\ttimeStamp: Date.now(),\n\t\t\tprompt: job.prompt || \"No prompt found\",\n\t\t\tmessages: job.messages,\n\t\t\tresult: response?.response || \"NONE\",\n\t\t\tconfig: JSON.stringify(job.modelConfig)\n\t\t})\n\n\t\treturn response;\n\t}\n\n\t/* CHATS */\n\n\trestoreChats = (chatRecords?: ChatRecord[]) => {\n\t\tchatRecords?.forEach(async (chatRecord) => await this.database.overwriteChats(chatRecord));\n\t\tthis.chats.forEach(async (chat) => {\n\t\t\tlet chatRecord: ChatRecord | undefined;\n\n\t\t\tif (chatRecords && chatRecords.length > 0) {\n\t\t\t\tchatRecord = chatRecords.find((elem) => { return elem.id === chat.id });\n\t\t\t} else {\n\t\t\t\tchatRecord = await this.database.getChat(chat.id);\n\t\t\t}\n\n\t\t\tif (chatRecord) {\n\t\t\t\tchat.history = chatRecord.history.map((h: HistoryRecord) => {\n\t\t\t\t\tconst companion = this.companions.find(c => {\n\t\t\t\t\t\treturn c.configuration.name.toLowerCase() === h.companion.toLowerCase();\n\t\t\t\t\t})\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...h,\n\t\t\t\t\t\tcompanion: companion!,\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t})\n\t}\n\n\tgetChat = (id: string) => this.chats.find(c => c.id == id);\n\tgetCompanionChat = (companion: Companion) => this.chats.find(c => c.id == companion.id + \"_chat\");\n\n\taddCompanionChat = (companion: Companion, situation: string) => {\n\t\treturn this.addChat(companion.id + \"_chat\", situation, [companion.id, \"you\"], 8, \"round_robin\");\n\t}\n\taddChat = (id: string, situation: string, companionIDs: string[], maxRounds: number = 8, speakerSelection: ChatSpeakerSelection = \"auto\") => {\n\t\tconst chatCompanions = this.companions.filter(c => companionIDs.includes(c.id) && (c.configuration.kind == \"npc\" || c.configuration.kind == \"user\"));\n\n\t\tconst existingChat = this.getChat(id);\n\n\t\t// Reconfigure existing chat if there is one\n\t\tif (existingChat) {\n\t\t\texistingChat.companions = chatCompanions;\n\t\t\texistingChat.maxRounds = maxRounds;\n\t\t\texistingChat.speakerSelection = speakerSelection;\n\t\t\tlogger.debug(\"Reconfiguring existing chat: \" + existingChat.id);\n\t\t\treturn existingChat;\n\t\t}\n\n\t\tconst chat = new Chat(this, id, situation, chatCompanions, maxRounds, speakerSelection);\n\t\tthis.chats.push(chat);\n\t\tlogger.info(\"New chat: \" + chat.id);\n\t\treturn chat;\n\t}\n\n\tremoveChat = (id: string) => {\n\t\tthis.chats = this.chats.filter(c => c.id != id);\n\t\tthis.database.deleteChat(id);\n\t};\n\n\trunConversation = async (chat: Chat, rounds: number, context: Context, lastSpeaker?: AutoCompanion, except?: Companion[], callback?: (chat: Chat, speaker?: AutoCompanion, message?: ChatMessage) => void): Promise<[Chat, AutoCompanion | undefined, AutoCompanion | undefined, Context | undefined]> => {\n\n\t\tif (rounds <= 0) return [chat, lastSpeaker, undefined, context];\n\n\t\tconst chatLines = chat.history.length;\n\n\t\tconst [newChat, newLastSpeaker, newActiveSpeaker, newContext] = await this.runChat(chat, rounds, context, lastSpeaker, except, callback);\n\n\t\tconst roundsTaken = newChat.history.length - chatLines;\n\n\t\t// return control to user\n\t\tif (newActiveSpeaker && newActiveSpeaker.configuration.kind == \"user\")\n\t\t\treturn [newChat, newLastSpeaker, newActiveSpeaker, newContext];\n\n\t\t// otherwise continue\n\t\treturn await this.runConversation(newChat, rounds - roundsTaken, newContext || context, newLastSpeaker, except, callback);\n\t}\n\n\trunChat = async (chat: Chat, rounds: number, context: Context, lastSpeaker?: AutoCompanion, except?: Companion[], callback?: (chat: Chat, speaker?: AutoCompanion, message?: ChatMessage) => void): Promise<[Chat, AutoCompanion | undefined, AutoCompanion | undefined, Context | undefined]> => {\n\n\t\t// We last asked a question\n\t\tif (chat.currentContext) {\n\t\t\tcontext.action = chat.currentContext.action;\n\t\t\tcontext.input = chat.lastMessage()?.message;\n\t\t\tcontext.question = undefined;\n\t\t}\n\n\t\tlet activeSpeakers = await chat.selectSpeakers(context, lastSpeaker, except);\n\n\t\t// for (const activeSpeaker of activeSpeakers) {\n\t\twhile (activeSpeakers.length && rounds >= 0) {\n\n\t\t\t// last speaker in the list gets set active\n\t\t\tconst activeSpeaker = activeSpeakers.pop();\n\n\t\t\tif (activeSpeaker && activeSpeaker.configuration.kind != \"user\") {\n\n\t\t\t\tlogger.info(\"Setting active speaker\", activeSpeaker);\n\n\t\t\t\tactiveSpeaker.status = \"active\";\n\t\t\t\trounds--;\n\n\t\t\t\tif (context.action)\n\t\t\t\t\tthis.logAction(activeSpeaker);\n\n\t\t\t\t// skip inference if we just post a quote\n\t\t\t\tif (context.quote == undefined) {\n\t\t\t\t\tcallback && callback(chat, activeSpeaker);\n\t\t\t\t\tcontext = await activeSpeaker.generateReply(chat, context, lastSpeaker);\n\t\t\t\t}\n\n\t\t\t\t// If the context has a message, we print it and call a callback. Excerpt gets preference if present. Quote gets printed unless a shell is speaking.\n\t\t\t\tconst excerpt = context.excerpt;\n\t\t\t\tconst message = context.message;\n\t\t\t\tconst quote = (activeSpeaker.configuration.kind != \"shell\") ? context.quote : undefined; // quotes by shells get wrapped\n\n\t\t\t\t// if there's either a comment or a quote, post it!\n\t\t\t\tconst answer = excerpt || message || quote;\n\t\t\t\tif (answer) {\n\t\t\t\t\t// append the last message to the chat\n\t\t\t\t\tconst appendedMessage = chat.appendMessage(activeSpeaker, answer, context);\n\t\t\t\t\tcallback && callback(chat, activeSpeaker, appendedMessage);\n\n\t\t\t\t\tif (excerpt) context.excerpt = undefined; // excerpt gets removed otherwise it gets added twice\n\t\t\t\t}\n\n\t\t\t\tactiveSpeaker.status = \"free\";\n\t\t\t\tlastSpeaker = activeSpeaker;\n\n\t\t\t\t// save the context if we're waiting for an answer\n\t\t\t\tif (context.question) chat.currentContext = context;\n\t\t\t} else {\n\t\t\t\t// active speaker is user -> return control\n\t\t\t\t// await db.logChat(chat.id, chat.history);\n\t\t\t\tawait this.database.writeChat(chat.id, chat.history);\n\t\t\t\tawait this.syncInteractions();\n\n\t\t\t\tcontext = await this.runTriggers(context, callback);\n\n\t\t\t\treturn [chat, lastSpeaker, activeSpeaker, context];\n\t\t\t}\n\t\t}\n\n\t\tawait this.database.writeChat(chat.id, chat.history);\n\t\tawait this.syncInteractions();\n\n\t\tcontext = await this.runTriggers(context, callback);\n\n\t\treturn [chat, lastSpeaker, undefined, context];\n\t}\n\n\t/* TRIGGERS */\n\n\trunTriggers = async (context: Context, callback?: (chat: Chat, speaker?: AutoCompanion, message?: ChatMessage) => void): Promise<Context> => {\n\n\t\tfor (const companion of this.companions) {\n\n\t\t\tif (!companion.configuration.triggers) continue;\n\n\t\t\tfor (const trigger of companion.configuration.triggers) {\n\t\t\t\tif (evaluateCondition(trigger.condition, this.worldState)) {\n\t\t\t\t\tif (typeof trigger.action == \"string\") {\n\n\t\t\t\t\t\t// run the action\n\n\t\t\t\t\t\tconst companionChat = this.getCompanionChat(companion);\n\t\t\t\t\t\tif (!companionChat) return context;\n\n\t\t\t\t\t\t// set event to false before executing action (so we don't run in circles)\n\t\t\t\t\t\tif (trigger.condition.tag == \"event\" && trigger.condition.value && typeof trigger.condition.value == \"string\") {\n\t\t\t\t\t\t\tawait this.setWorldStateEntry(trigger.condition.value, false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontext.recipient = companion;\n\t\t\t\t\t\tcontext.action = trigger.action;\n\t\t\t\t\t\tconst result = await this.runChat(companionChat, 5, context, undefined, undefined, callback);\n\n\t\t\t\t\t\treturn result[3] || context; // the result context (or the original if we got an undefined one back)\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif (!trigger.effect) continue;\n\n\t\t\t\t\t\t// manipulate the world state\n\t\t\t\t\t\tif (trigger.effect.tag == \"event\" && trigger.effect.value && typeof trigger.effect.value == \"string\") {\n\t\t\t\t\t\t\t// send an event\n\t\t\t\t\t\t\tawait this.setWorldStateEntry(trigger.effect.value, true);\n\n\t\t\t\t\t\t\tlogger.info(\"Setting event \" + trigger.effect.value + \" with condition \" + trigger.condition);\n\n\t\t\t\t\t\t} else if (trigger.effect.tag == \"action\" && trigger.effect.value && typeof trigger.effect.value == \"string\") {\n\n\t\t\t\t\t\t\t// run the action\n\t\t\t\t\t\t\tconst companionChat = this.getCompanionChat(companion);\n\t\t\t\t\t\t\tif (!companionChat) return context;\n\t\t\t\t\t\t\tcontext.recipient = companion;\n\t\t\t\t\t\t\tcontext.action = trigger.effect.value;\n\t\t\t\t\t\t\tconst result = await this.runChat(companionChat, 5, context, undefined, undefined, callback);\n\t\t\t\t\t\t\treturn result[3] || context; // the result context (or the original if we got an undefined one back)\n\n\t\t\t\t\t\t} else if (typeof trigger.effect.tag == \"string\" && trigger.effect.value) {\n\n\t\t\t\t\t\t\t// manipulate the world state\n\t\t\t\t\t\t\tswitch (trigger.action) {\n\t\t\t\t\t\t\t\tcase \"set\":\n\t\t\t\t\t\t\t\t\tawait this.setWorldStateEntry(trigger.effect.tag, trigger.effect.value);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"add\":\n\t\t\t\t\t\t\t\t\tif (typeof trigger.effect.value == \"number\")\n\t\t\t\t\t\t\t\t\t\tawait this.increaseWorldStateEntry(trigger.effect.tag, trigger.effect.value);\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tlogger.error(\"Operation '\" + trigger.action + \"' needs a value in the condition that is number!\");\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault: logger.error(\"Operation '\" + trigger.action + \"' is not implemented yet!\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.error(\"Triggers with operation '\" + trigger.action + \"' can only operate on a world state or send an event. Also it needs a value set in the condition.\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn context;\n\t}\n}\n","import { KyInstance, Options } from \"ky\";\nimport { ModelConfig, defaultModelConfig } from \"./config/models\";\nimport { PromptConfig, PromptTemplate } from \"./config/prompts\";\nimport { Job } from \"./job\";\nimport { logger } from \"./utils/logging-utils\";\n\n/**\n * The response from the backend/model including the number of tokens in and out.\n *\n * @export\n * @interface JobResponse\n */\nexport interface JobResponse {\n\tid: string;\n\tresponse: string | undefined;\n\tinput_tokens: number | undefined;\n\toutput_tokens: number | undefined;\n\n\t/** The following properties are unavailable in OpenAI-compatible response schema */\n\t// status: string | undefined;\n\t// error: string | boolean | undefined;\n\t// runtime: number | undefined;\n}\n\nexport type Messages = {\n\trole: string,\n\tcontent: string,\n}[];\n\ntype OptionalPropsType<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\ntype GenerationParams = OptionalPropsType<ModelConfig, 'extra'>;\ninterface RequestPayload extends GenerationParams {\n\tprompt?: string,\n\tmessages?: Messages,\n\tpreset?: string,\n\tchat_id?: string,\n\tsituation_id?: string,\n\tinteraction_id?: string,\n}\n\n/**\n * Custom error class to wrap the job response\n *\n * @export\n * @class ModelError\n * @extends {Error}\n */\nexport class ModelError extends Error {\n\treason: string;\n\tjob: Job;\n\tjobResponse?: JobResponse;\n\terror?: Error;\n\n\tconstructor(msg: string, reason: string, job: Job, jobResponse?: JobResponse, error?: Error) {\n\t\tsuper(msg);\n\t\tthis.reason = reason;\n\t\tthis.job = job;\n\t\tthis.jobResponse = jobResponse;\n\t\tthis.error = error;\n\n\t\t// Set the prototype explicitly.\n\t\tObject.setPrototypeOf(this, ModelError.prototype);\n\t}\n}\n\n/**\n * A model is an abstraction of a language model.\n *\n * @export\n * @class Model\n */\nexport class Model {\n\tprivate modelConfig: ModelConfig = defaultModelConfig;\n\tprivate path: string;\n\n\t/**\n\t * All tokens sent to the model\n\t *\n\t * @type {number}\n\t * @memberof Model\n\t */\n\tinputTokens: number = 0;\n\t/**\n\t * All tokens received from the model\n\t *\n\t * @type {number}\n\t * @memberof Model\n\t */\n\toutputTokens: number = 0;\n\t/**\n\t * Accumulated runtime\n\t *\n\t * @type {number}\n\t * @memberof Model\n\t */\n\truntime: number = 0.0;\n\tpromptTemplate: PromptTemplate = this.modelConfig.extra.template;\n\tpromptConfig: PromptConfig = this.modelConfig.extra.promptConfig;\n\n\t/**\n\t * Creates an instance of Model.\n\t * @param {string}\n\t * @memberof Model\n\t */\n\tconstructor(path: string) {\n\t\tthis.path = path.startsWith('/') ? path.slice(1) : path;\n\t\treturn this;\n\t}\n\n\tprivate jsonToJobResponse = (jsonResponse: any) => {\n\t\ttry {\n\t\t\tconst jobResponse: JobResponse = {\n\t\t\t\tid: jsonResponse.id, // job_id\n\t\t\t\tresponse: jsonResponse.response || jsonResponse.choices[0]?.text || jsonResponse.choices[0]?.message?.content, // generated text - change this if n > 1 in inference params\n\t\t\t\tinput_tokens: jsonResponse.usage?.prompt_tokens, // runtime of the request\n\t\t\t\toutput_tokens: jsonResponse.usage?.completion_tokens, // runtime of the request\n\n\t\t\t\t/** The following properties are unavailable in OpenAI-compatible response schema */\n\t\t\t\t// status: jsonResponse.data?.status, // job status\n\t\t\t\t// error: !jsonResponse.status ? jsonResponse.detail : false, // API-response status or a detail\n\t\t\t\t// runtime: jsonResponse.runtime, // runtime of the request\n\t\t\t}\n\t\t\treturn jobResponse;\n\t\t}\n\t\tcatch (error) {\n\t\t\tlogger.error('Error parsing JSON:', error);\n\t\t\tthrow new Error(\"JSON Parsing error.\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Builds a complete response object from an event-stream response.\n\t *\n\t * Useful, when streaming directly to user-facing components is not available.\n\t *\n\t * Waits for the streaming response to end and builds a response object that is the same\n\t * as the response object when not streaming i.e., json response.\n\t *\n\t * @private\n\t * @param {Response} response\n\t * @memberof Model\n\t */\n\tprivate buildResponseFromStream = async (response: Response) => {\n\t\t// Mostly taken from https://stackoverflow.com/a/75751803\n\n\t\tlet buffer: string = '';\n\t\tlet completeResponse: string[] = []\n\t\tlet completedData: any = null;\n\n\t\tconst reader = response.body?.pipeThrough(new TextDecoderStream()).getReader();\n\t\tif (!reader) {\n\t\t\tthrow new Error('Response body is unreadable or cannot be decoded as text.');\n\t\t};\n\n\t\twhile (true) {\n\t\t\tlet dataDone = false;\n\t\t\tconst { done, value } = await reader.read();\n\n\t\t\tif (done || dataDone) {\n\t\t\t\tif (completedData) {\n\t\t\t\t\tcompletedData.response = completeResponse.join('');\n\t\t\t\t\treturn completedData;\n\t\t\t\t}\n\t\t\t\tthrow new Error(\"Error in response stream or incomplete stream received.\")\n\t\t\t}\n\n\t\t\tbuffer += value;\n\t\t\tconst lines = buffer.split('\\n');\n\n\t\t\tlines.forEach((data) => {\n\t\t\t\tconst line = data.trim();\n\n\t\t\t\tif (!line) return;\n\t\t\t\tif (!line.startsWith('data:')) return;\n\t\t\t\tif (line === 'data: [DONE]') return;\n\n\t\t\t\tconst dataMessage = line.substring(5).trim();\n\t\t\t\tlogger.debug(`Data: ${dataMessage}\\n`);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst dataObject = JSON.parse(dataMessage);\n\t\t\t\t\tcompletedData = dataObject;\n\n\t\t\t\t\t/**\n\t\t\t\t\t * NOTE:\n\t\t\t\t\t * In a streaming response, `responseChunk` will contain a single token.\n\t\t\t\t\t * If streaming directly to UI components, yield every `responseChunk`.\n\t\t\t\t\t */\n\t\t\t\t\tconst responseChunk: string = dataObject.choices[0]?.text || dataObject.choices[0]?.delta?.content || '';\n\t\t\t\t\tcompleteResponse.push(responseChunk);\n\t\t\t\t\tbuffer = '';\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.debug('Received non-JSON stream chunk:', line);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t};\n\n\tprivate processPOSTResponse = async (response: Response): Promise<JobResponse> => {\n\t\tlet jsonResponse;\n\n\t\tconst contentType = response.headers.get('content-type');\n\t\tconst responseIsStream = contentType && contentType.includes('text/event-stream')\n\n\t\tlogger.debug(\"Response is of type \" + contentType);\n\n\t\tif (!responseIsStream) {\n\t\t\tjsonResponse = await response.json();\n\t\t} else {\n\t\t\tjsonResponse = await this.buildResponseFromStream(response);\n\t\t}\n\n\t\tconst dataObject: JobResponse = this.jsonToJobResponse(jsonResponse);\n\t\treturn dataObject;\n\t};\n\n\n\t/**\n\t * Call this function to run a job. Returns a job response and updates the local db.\n\t *\n\t * @param {Job} job\n\t * @param {KyInstance} instance\n\t * @param {Options} [additionalOptions]\n\t * @memberof Model\n\t */\n\trunJob = async (job: Job, instance: KyInstance, additionalOptions?: Options): Promise<JobResponse | undefined> => {\n\t\tlet jobResponse: JobResponse | undefined = undefined;\n\n\t\tconst presetAction = job.context.action;\n\n\t\tif (!(job.prompt || job.messages)) throw new ModelError(\"Can not run inference\", \"No prompt or messages array found.\", job);\n\n\t\tconst postData: RequestPayload = {\n\t\t\tprompt: job.prompt,\n\t\t\tmessages: job.messages,\n\t\t\tpreset: presetAction,\n\t\t\tchat_id: job.context.chatID,\n\t\t\tsituation_id: job.context.situation,\n\t\t\tinteraction_id: job.context.interactionID,\n\t\t\t...(job.modelConfig || this.modelConfig),\t// job can override parameters\n\t\t}\n\t\tdelete postData[\"extra\"];\n\n\t\treturn instance.post(this.path, {\n\t\t\tjson: postData,\n\t\t\t...additionalOptions\n\t\t}).then(async (res) => {\n\t\t\tjobResponse = await this.processPOSTResponse(res);\n\n\t\t\t// keep track of stats\n\t\t\tjobResponse.input_tokens && (this.inputTokens += jobResponse.input_tokens);\n\t\t\tjobResponse.output_tokens && (this.outputTokens += jobResponse.output_tokens);\n\t\t\t// jobResponse.runtime && (this.runtime += jobResponse.runtime);\n\n\t\t\tif (!jobResponse.id) {\n\t\t\t\t// logger.debug(jobResponse);\n\t\t\t\tthrow new Error(\"Job ID not found!\");\n\t\t\t}\n\t\t\t// if (jobResponse.status != \"COMPLETED\") {\n\t\t\t// \tthrow new ModelError(\"Job failed! COMPLETED not set.\", \"Invalid response status.\", job, jobResponse);\n\t\t\t// }\n\n\t\t\treturn jobResponse;\n\t\t}).catch((e) => {\n\t\t\t// db.prompts.add({ timeStamp: Date.now(), prompt: job.prompt || \"No prompt found\", result: \"ERROR: \" + JSON.stringify(e), config: JSON.stringify(this.modelConfig) });\n\n\t\t\tlogger.error(e);\n\n\t\t\tthrow new ModelError(\"Job failed!\", \"Invalid response.\", job, undefined, e instanceof Error ? e : undefined);\n\t\t})\n\t}\n}","import { Template } from \"@huggingface/jinja\";\nimport { ChatMessage } from \"./chat\";\nimport { Companion } from \"./companions/companion\";\nimport { evaluateCondition } from \"./conditions\";\nimport { PromptConfig, PromptTemplate, defaultPromptConfig } from \"./config/prompts\";\nimport { Context, ContextDataTypes, ContextDecorator, defaultDecorators } from \"./context\";\nimport { KeyValueRecord } from \"./db/database\";\nimport { getRandomElement } from \"./utils/array-utils\";\nimport { logger } from \"./utils/logging-utils\";\nimport { unixTimestampToDate } from \"./utils/time-utils\";\nimport { Messages } from \"./model\";\n\n/**\n * A simple wrapper to make it possible to append text if and only if the text is not undefined. Separator between old\n * and new text can be set. Always appends at the end.\n *\n * @class Prompt\n */\nclass Prompt {\n\t/**\n\t * The current prompt\n\t *\n\t * @type {string}\n\t * @memberof Prompt\n\t */\n\tprompt: string;\n\tconstructor(basePrompt: string) { this.prompt = basePrompt; return this; };\n\n\tappend = (data?: string, separator = \"\\n\") => {\n\t\tdata && (this.prompt = this.prompt + separator + data);\n\t\treturn this;\n\t}\n}\n\n/**\n * Assemble the prompt.\n *\n * @export\n * @class Prompter\n */\nexport class Prompter {\n\t/**\n\t * The (jinja) prompt template to use\n\t *\n\t * @private\n\t * @type {Template}\n\t * @memberof Prompter\n\t */\n\tprivate template: Template;\n\t/**\n\t * A template for the template\n\t *\n\t * @private\n\t * @type {PromptTemplate}\n\t * @memberof Prompter\n\t */\n\tprivate config: PromptTemplate;\n\n\t/**\n\t * Creates an instance of Prompter.\n\t * @param {PromptTemplate} config\n\t * @memberof Prompter\n\t */\n\tconstructor(config: PromptTemplate) {\n\t\tthis.template = new Template(config.chat_template);\n\t\tthis.config = config;\n\t}\n\n\t/**\n\t * Decorate the prompt using data.\n\t *\n\t * @private\n\t * @param {ContextDataTypes} type\n\t * @param {string} [text]\n\t * @param {ContextDecorator[]} [decorators]\n\t * @memberof Prompter\n\t */\n\tprivate decorate = (type: ContextDataTypes, text?: string, decorators?: ContextDecorator[]) => {\n\t\tif (!text || !decorators) return undefined;\n\t\tconst decorator = decorators.find(d => d.type == type);\n\t\treturn decorator && decorator.replacement.replace(\"{{DATA}}\", text);\n\t}\n\n\t/**\n\t * Clean the string\n\t *\n\t * @private\n\t * @param {string} text\n\t * @memberof Prompter\n\t */\n\tprivate sanitize = (text: string) => {\n\t\treturn text.replace(/<.*>/gi, \"\").trim();\n\t}\n\n\t/**\n\t * Use jinja to render the prompt using the current configuration and template.\n\t *\n\t * @param {string} speaker\n\t * @param {{ role: string, content: string }[]} chat\n\t * @param {Template} [template=this.template]\n\t * @memberof Prompter\n\t */\n\trenderPrompt = (speaker: string, chat: { role: string, content: string }[], template: Template = this.template) => {\n\t\tconst result = template.render({\n\t\t\tmessages: chat,\n\t\t\tbos_token: this.config.bos_token,\n\t\t\teos_token: this.config.eos_token,\n\t\t\tspeaker: speaker,\n\t\t});\n\n\t\tif (true) {\n\t\t\tlogger.debug(\"Prompt: \", result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Assemble the prompt for one inference using the supplied data and world state.\n\t *\n\t * @param {Companion} companion\n\t * @param {KeyValueRecord[]} worldState\n\t * @param {Context} context\n\t * @param {ChatMessage[]} [history]\n\t * @param {ContextDecorator[]} [decorators=[]]\n\t * @param {PromptConfig} [config=defaultPromptConfig]\n\t * @param {PromptTemplate} [promptTemplate]\n\t * @param {returnChat} [returnChat]\n\t */\n\tassemblePrompt = (companion: Companion,\n\t\tworldState: KeyValueRecord[],\n\t\tcontext: Context,\n\t\thistory?: ChatMessage[],\n\t\tdecorators: ContextDecorator[] = [],\t// eventual additional decorators\n\t\tconfig: PromptConfig = defaultPromptConfig,\n\t\tpromptTemplate?: PromptTemplate,\n\t\treturnChat: boolean = false): string | Messages => {\n\n\t\tlet tags: string[] = [];\n\t\tcompanion.configuration.knowledge && companion.configuration.knowledge\n\t\t\t.filter((knowledge) => knowledge.condition && evaluateCondition(knowledge.condition, worldState))\n\t\t\t.forEach((knowledge) => tags.push(getRandomElement(knowledge.lines)));\n\n\t\tconst allDecorators = defaultDecorators.concat(decorators);\n\n\t\tconst questionData = this.decorate(\"question\", context.question, allDecorators);\n\t\tconst personaData = this.decorate(\"persona\", context.persona, allDecorators);\n\t\tconst jobData = config.job_in_chat ? undefined : this.decorate(\"job\", context.job, allDecorators);\n\t\tconst answerData = this.decorate(\"answer\", context.answer, allDecorators);\n\t\tconst messageData = this.decorate(\"message\", context.message, allDecorators);\n\t\tconst quoteData = this.decorate(\"quote\", context.quote, allDecorators);\n\t\tconst epilogueData = this.decorate(\"epilogue\", context.epilogue, allDecorators);\n\t\tconst chatData = this.decorate(\"chat\", context.chat, allDecorators);\n\n\t\tconst textData = this.decorate(\"text\", context.text, allDecorators);\n\t\tconst paragraphData = this.decorate(\"paragraph\", context.paragraph, allDecorators);\n\t\tconst inputData = textData || paragraphData || this.decorate(\"text\", context.input, allDecorators);;\n\n\t\tlogger.debug(\"context\", { ...context });\n\t\tlogger.debug(\"input data\", context.query()?.substring(0, 250));\n\n\t\tconst moodData = companion.mood.prompt;\n\n\t\t// leave out shell companions because they are never a part of the chat history\n\t\tconst otherCompanions = context.companions.filter(c => c.configuration.kind != \"shell\" && c.id != companion.id).map(c => c.configuration.description);\n\t\tconst companionList = otherCompanions && otherCompanions.join(\"\\n\");\n\n\t\t// if there's an action we exclude knowledge, companions & situation\n\t\tconst isAction = context.action != undefined;\n\t\tconst knowledgeData = isAction ? undefined : this.decorate(\"knowledge\", tags.join(\"\\n\"), allDecorators);\n\t\tconst situationData = isAction ? undefined : companion.configuration.situations?.find(s => s.id == context.situation)?.prompt;\n\t\tconst companionData = isAction ? undefined : (companionList && this.decorate(\"companionNames\", companionList, allDecorators));\n\t\tconst currentTimeData = isAction ? undefined : \"It is currently \" + unixTimestampToDate(Date.now());\n\n\t\tconst system_prompt = new Prompt(\"\")\n\t\t\t.append(companion.getBasePrompt())\n\t\t\t.append(personaData || situationData)\n\t\t\t.append(currentTimeData)\n\t\t\t.append(companionData)\n\t\t\t.append(knowledgeData)\n\t\t\t.append(moodData)\n\t\t\t.append(jobData)\n\t\t\t.append(inputData)\n\t\t\t.append(messageData)\n\t\t\t.append(answerData)\n\t\t\t.append(questionData)\n\t\t\t.append(quoteData)\n\t\t\t.append(chatData)\n\t\t\t.append(epilogueData)\n\t\t\t;\n\n\n\n\t\t// only add history if there is one and if we don't have answerData\n\t\tconst chat: { role: string, content: string }[] = [];\n\t\tlet cutoff = 0;\n\t\tif (history && (history.length > 0) && !answerData && !epilogueData && !jobData && !chatData) {\n\n\t\t\tconst username = worldState.find(w => w.key == \"USERNAME\")?.value;\n\n\t\t\thistory\n\t\t\t\t.filter(m => m.companion.configuration.kind != \"shell\")\n\t\t\t\t.forEach(line => chat.push(\n\t\t\t\t\t{\n\t\t\t\t\t\trole: (line.companion.id == \"you\") ?\n\t\t\t\t\t\t\t((!returnChat && username && typeof (username) == \"string\") ? username : 'user')\n\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t((line.companion.id == companion.id) ? \"assistant\" : !returnChat ? line.companion.configuration.name : \"user\"),\n\t\t\t\t\t\tcontent: this.sanitize(line.message)\n\t\t\t\t\t}));\n\n\t\t\tlet budget = config.max_prompt_length - system_prompt.prompt.length - 255; // keep a little bit of buffer for tokens\n\t\t\tchat.reverse()\n\t\t\t\t.every((entry, index) => {\n\t\t\t\t\tbudget -= entry.content.length + entry.role.length + 6; // colon, space, 2x newline, start and end token\n\t\t\t\t\tif (budget < 0) {\n\t\t\t\t\t\tcutoff = index;\n\t\t\t\t\t\treturn false; // early exit\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t})\n\t\t}\n\n\t\tconst start = 0\n\t\tconst end = cutoff !== 0 ? cutoff : history?.length\n\t\tconst cleaned_chat = [{ role: config.system_role_allowed ? \"system\" : \"user\", content: this.sanitize(system_prompt.prompt) }, ...chat.slice(start, end).reverse()];\n\n\t\t// append the job if configured as such\n\t\tconst job = context.job;\n\t\tif (config.job_in_chat && job) {\n\t\t\tcleaned_chat.push({ role: \"user\", content: this.sanitize(job) })\n\t\t}\n\n\t\tif (returnChat) {\n\t\t\treturn cleaned_chat;\n\t\t}\n\n\t\tconst name = \"assistant\"; //companion.configuration.kind == \"shell\" ? \"assistant\" : companion.id;\n\n\t\t// If a template is provided, use that\n\t\t// Else, check if the companion uses a different model/template\n\t\t// Else, use the default template\n\t\tlet template = promptTemplate?.chat_template || companion.configuration.modelConfig?.extra?.template?.chat_template;\n\n\t\treturn this.renderPrompt(name, cleaned_chat, template ? new Template(template) : undefined);\n\t}\n\n\n}\n\n","\nexport const secondsToString = (interval: number) => {\n\tswitch (interval) {\n\t\tcase 3600: return \"LAST HOUR\";\n\t\tcase 86400: return \"LAST 24H\";\n\t\tcase 604800: return \"LAST WEEK\";\n\t\tcase 2592000: return \"LAST MONTH\";\n\t}\n\treturn \"SINCE THE DAWN OF TIME\";\n}\n\nexport const unixTimestampToDate = (timestamp: number) => {\n\tconst options: Intl.DateTimeFormatOptions = {\n\t\tweekday: \"short\",\n\t\tyear: \"numeric\",\n\t\tmonth: \"short\",\n\t\tday: \"numeric\",\n\t\thour: \"2-digit\",\n\t\tminute: \"2-digit\",\n\t\tsecond: \"2-digit\"\n\t};\n\tlet dt = new Date(timestamp).toLocaleDateString(\"default\", options);\n\treturn dt;\n}\n\nexport const timeToString = (date: Date) => {\n\tconst hours = date.getHours();\n\tconst minutes = \"0\" + date.getMinutes();\n\tconst seconds = \"0\" + date.getSeconds();\n\n\treturn hours + ':' + minutes.substring(-2) + ':' + seconds.substring(-2);\n\t// logger.debug(formattedTime);\n}\n\nexport function formatRelativeDate(date: number) {\n\tlet diff = Date.now() - date * 1000; // the difference in milliseconds\n\n\tif (diff < 10000) { // less than 1 second\n\t\treturn 'now';\n\t}\n\n\tconst sec = Math.floor(diff / 1000);\n\tif (sec < 60) {\n\t\treturn sec + 's';\n\t}\n\n\tconst min = Math.floor(diff / (1000 * 60));\n\tif (min < 60) {\n\t\treturn min + 'm';\n\t}\n\n\tconst hours = Math.floor(diff / (1000 * 60 * 60));\n\tif (hours < 60) {\n\t\treturn hours + 'h';\n\t}\n\n\tconst days = Math.floor(diff / (1000 * 60 * 60 * 24));\n\tif (days < 14) {\n\t\treturn days + 'd';\n\t}\n\n\treturn unixTimestampToDate(date);\n}\n\nexport function getMidnightUtc(): Date {\n\tconst maxTimeToday = new Date();\n\tmaxTimeToday.setUTCHours(23, 59, 59, 999);\n\treturn new Date(maxTimeToday.getTime() + 1);\n}\n\nexport function nextCreditsResetCountdownString(creditsTtl: number): string {\n\treturn new Date(creditsTtl).toISOString().slice(11, 19);\n}\n"],"mappings":"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","names":["entry","c","uuidv4","ky"]}